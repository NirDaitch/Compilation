
%{
	#include <iostream>
	#include "definitions.h"
	#include <algorithm>
	#include "output.hpp"
	#include "bp.hpp"
	#include <sstream>
	#include <stdio.h>
	#include <map>
	

	#define VAR_SIZE 4
	using namespace std;
	using namespace output;

	
	extern int yylineno;
	extern int yylex();
	int yyerror(const char *);

	///////// OUR GLOBAL VARS DEFINITIONS//////////
	int m_iWhileCounter = 0;
	ScopeStack m_stScopeStack;
	int m_iCurrentOffset = 0;
	vector<string>  TYPES_TO_STRING;
	
	int registerPool[26];
	vector<int> RABpatchMagic(0);
	vector<int> usedRegsByExplist;
	int currentRegisterPool[26];
	////////////////CURRENT FUCNTION DATA///////////////
	int m_iFUNCTION_CurrentOffset = -1;
	list<T_Symbol> funcArgs;
	
	vector<EXP_ATTRIBUTE> funcCallTypes;


	///////// OUR FUNCTIONS DEFINITIONS//////////
	void validateNotAlreadyDefined(string name);
	void validateDefined(string name, bool isVariable);
	void validateAssignment(Type lhs, Type rhs);
	void validateAssignmentDynamic(string nameLHS, string rhsName, Type rhsType, bool rhs_is_array);
	Type validateAndGetTypeByName(string name, bool isVariable);
	void checkByteSize(int value, string valueInStringForm);
	void createAndPushSymbol(string name, Type type, int size);
	void checkFuncValidReturn(Type type,int size,bool return_value_is_array);
	T_Symbol createFunctionSymbol(string name, Type type, int size);
	void createFunctionObj(string name, Type type);
	void addFunctionToSymbolTable(string name, Type returnType, list<T_Symbol> args);
	
	void checkRHSNotArray(bool is_array);
	void validateIsArray(string name);
	
	void validateCallFunction(string funcName, vector<EXP_ATTRIBUTE> callArgs);
	void validateFunctionArg(string varName);
	bool contains(list<T_Symbol> lstStrings, string sym);
	vector<string> generateStringTypes(list<T_Symbol> lstArgs);
	
	bool getIsArray(string name);
	
	void start_Scope();
	void start_scope_function();
	void program_scope_start();
	
	void end_Scope();
	int getExpSizeFromTable(string name);
	void isBoolean(Type t);
	void isIntOrByte(Type t);
	void validateArraySize(int numValue, string name);
	
	void checkHasMain();
	
	Type getTypeBinop(Type t1, Type t2);
	T_Symbol getSymbol(string name);
	
	
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5*/	
	
	void initRegisterPool();
	void loadRegisterPool();
	void initCurrentRegisterPool();
	void saveCurrentRegisterPool();
	void markAllRegisterPool();
	int getFirstAvailableRegister();
	void markRegisterUnused(int iRegisterNumber);
	void markRegisterUsed(int iRegisterNumber);
	void saveAllRegisters();
	void loadAllRegisters();
	int getOffset(string name);
	void storeValInStack(string variable, int iRegisterNumber);	
	void loadValFromStack(string variable, EXP_ATTRIBUTE& leftexp);
	void addPrintHelper();
	void addPrintiHelper();
	void storeFuncRetAddrInStack(int numOfArgs);
	void storeValListInStack(vector<int> values);
	void initializeStackFP();
	void addPrintFunc();
	void addPrintiFunc();
	void bpIF2Statement(EXP_ATTRIBUTE& S,EXP_ATTRIBUTE B, EXP_ATTRIBUTE M1, EXP_ATTRIBUTE M2, EXP_ATTRIBUTE S1, EXP_ATTRIBUTE N, EXP_ATTRIBUTE S2);
	void beforeFuncCall();
	void popStackAfterFunction (int size);
	int generateBinopRes1(string op, EXP_ATTRIBUTE b1, EXP_ATTRIBUTE b2,Type resType);
	int generateBinopRes2(string op, EXP_ATTRIBUTE b1, EXP_ATTRIBUTE b2, Type resType);
	void createRelop(EXP_ATTRIBUTE& leftExp, int reg1, int reg2, string op);
	void performAnd(EXP_ATTRIBUTE& leftExp, EXP_ATTRIBUTE e1,EXP_ATTRIBUTE e2, EXP_ATTRIBUTE M);
	void performOr(EXP_ATTRIBUTE& leftExp, EXP_ATTRIBUTE e1,EXP_ATTRIBUTE e2, EXP_ATTRIBUTE M);
	string performRelop(int reg1, int reg2, string op);
	
	string performDiv_ResInB1(int iB1Register, int iB2Register);
	string performMul_ResInB1(int iB1Register, int iB2Register, int areBothByte);
	string performAddByte_ResInResRegister(int iB1Register, int iB2Register, int resRegister);
	string performAddInt_ResInResRegister(int iB1Register, int iB2Register, int resRegister);
	string performSubInt_ResInResRegister(int iB1Register, int iB2Register, int resRegister);
	string performSubByte_ResInResRegister(int iB1Register, int iB2Register, int resRegister);
	string intToString(int theInt);
	int putNumInRegister(int num_value);
	void generateMMarker(EXP_ATTRIBUTE& exp);
	void generateNMarker(EXP_ATTRIBUTE& exp);
	
	void handleBoolean(EXP_ATTRIBUTE& exp);	
	
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5*/	
	
%}

%token VOID INT BYTE RETURN B SC COMMA ID STRING TRUE FALSE

%nonassoc RPAREN LPAREN LBRACE RBRACE LBRACK RBRACK

%nonassoc IF
%nonassoc ELSE
 
%token WHILE
%token BREAK
%token NUM
%token BOOL

%right ASSIGN

%left OR    
%left AND    

%left 	RELOP_2
%nonassoc RELOP_1

%left BINOP_2
%left BINOP_1

%right NOT




%%

Program		:	ProgramScopeStart Funcs {checkHasMain();} ProgramScopeEnd ;

Funcs		:	FuncDecl	Funcs
			|	;

FuncDecl	:	 FuncDeclStart	RetType	ID	LPAREN	Formals {
					CodeBuffer::instance().emit($3.name+":");
					initializeStackFP();
					storeFuncRetAddrInStack($5.sizeForStack); 
				} RPAREN {validateNotAlreadyDefined($3.name);	createFunctionObj($3.name,$2.type);}	LBRACE ScopeStartFunction Statements M RBRACE  

				{
					CodeBuffer::instance().bpatch(RABpatchMagic,$12.instr);
					RABpatchMagic.erase(RABpatchMagic.begin(),RABpatchMagic.end());
					popStackAfterFunction($5.sizeForStack); 
					if( $3.name=="main")
					{
						CodeBuffer::instance().emit("li\t$v0 , 10\n");
						CodeBuffer::instance().emit("syscall\n");
					}
					else CodeBuffer::instance().emit("jr\t$ra\n");


					//for(int i=0;i<26;i++)
						//cout<<"regpool["<<i<<"]="<<registerPool[i]<<" , currentRegPool[i]="<<currentRegisterPool[i]<<endl;
						//todo-remove cout

					loadRegisterPool();


				} ScopeEnd/*TODO- maybe put it back where it belonged at the end of line 170*/
			;

FuncDeclStart:	{m_iFUNCTION_CurrentOffset = -1; funcArgs.clear();saveCurrentRegisterPool();};	

RetType		:	Type {$$.type=$1.type;}
			| 	VOID {$$.type=Type_VOID;}
			;

Formals		:	FormalsList {$$.sizeForStack = $1.sizeForStack;}
			|	;

FormalsList	:	FormalDecl {$$.sizeForStack = 1;}
			|	FormalDecl	COMMA	FormalsList {$$.sizeForStack = $3.sizeForStack+1;}
			;
				
FormalDecl	:	Type	ID { funcArgs.push_back(createFunctionSymbol($2.name, $1.type, -1));}
			|	Type	ID	LBRACK	NUM	RBRACK { validateArraySize($4.num_value, $2.name); funcArgs.push_back(createFunctionSymbol($2.name, $1.type, $4.num_value));}
			|	Type	ID	LBRACK	NUM		B	RBRACK { checkByteSize($4.num_value, $4.name); validateArraySize($4.num_value, $2.name);  funcArgs.push_back(createFunctionSymbol($2.name, $1.type, $4.num_value));}
			;
				
Statements	:	Statement {CodeBuffer::instance().bpatch($1.nextList, CodeBuffer::instance().genLabel());}
			|	Statements	 Statement {CodeBuffer::instance().bpatch($2.nextList, CodeBuffer::instance().genLabel());}
			;

Statement	:	LBRACE	 ScopeStart	Statements RBRACE {/* TODO: $$.nextList=$3.nextList;    TODO !.!*/} ScopeEnd 
			|	Type	ID	SC 	{  validateNotAlreadyDefined($2.name); createAndPushSymbol($2.name, $1.type,-1);}/*TODO-check!.!*/
			|	Type	ID	ASSIGN	Exp	SC	
				{ 
					validateNotAlreadyDefined($2.name); validateAssignment($1.type, $4.type); 
					createAndPushSymbol($2.name, $1.type,-1); 
					
					if ($1.type == Type_BOOL) 
					{
						handleBoolean($4);
					}
					storeValInStack($2.name, $4.resultReg);
				}
			|	Type	ID	LBRACK	NUM	RBRACK	SC 
				{  
					validateNotAlreadyDefined($2.name); 
					isIntOrByte($4.type); 
					validateArraySize($4.num_value, $2.name); 
					createAndPushSymbol($2.name, $1.type,$4.num_value); 
				}
			|	Type	ID	LBRACK	NUM	B 	RBRACK SC 
				{	
					validateNotAlreadyDefined($2.name); 
					isIntOrByte($4.type); 
					checkByteSize($4.num_value, $4.name); 
					validateArraySize($4.num_value, $2.name); 
					createAndPushSymbol($2.name,$1.type,$4.num_value); 
					/*we take: A[5 b] same as: A[5]*/ 
				}
			|	ID	ASSIGN	Exp	SC 
				{  
					validateDefined($1.name,true);  
					validateAssignmentDynamic($1.name, $3.name, $3.type,$3.is_array);
					if ($3.type == Type_BOOL) 
					{
						handleBoolean($3);
					}
					storeValInStack($1.name, $3.resultReg);
				}
			|	ID	LBRACK  Exp RBRACK ASSIGN Exp SC  
				{  
					validateDefined($1.name,true); 
					isIntOrByte($3.type); 
					validateAssignment(validateAndGetTypeByName($1.name, true), $6.type); 
					checkRHSNotArray($6.is_array); 
					validateIsArray($1.name);
					if ($6.type == Type_BOOL) 
					{
						handleBoolean($6);
					}
					storeValInStack($1.name, $6.resultReg);
					
				}
			|	Call SC
			|	RETURN  SC {checkFuncValidReturn(Type_VOID,-1, false); int tmp = CodeBuffer::instance().emit("b ");RABpatchMagic.push_back(tmp);}
			|	RETURN  Exp SC {checkFuncValidReturn($2.type,getExpSizeFromTable($2.name),$2.is_array);

				//CodeBuffer::instance().emit("move\t$v0 ," + intToString($2.resultReg) + "\n" ); todo- when enabling this, 2 tests fail
				if ($2.type == Type_BOOL) 
					{
						handleBoolean($2);
						
					}
				markRegisterUnused($2.resultReg);
				int tmp = CodeBuffer::instance().emit("b ");
				RABpatchMagic.push_back(tmp);


				}
			| 	IF LPAREN  Exp_boolean RPAREN ScopeStart M  Statement ScopeEnd {CodeBuffer::instance().bpatch($3.trueList,$6.instr); $$.nextList=CodeBuffer::instance().merge($3.falseList,$7.nextList);} 
			|   IF LPAREN  Exp_boolean RPAREN ScopeStart M  Statement ScopeEnd ELSE ScopeStart N M Statement {bpIF2Statement($$,$3,$6,$12,$7,$11,$13);} ScopeEnd
			|	WHILE startWhile LPAREN  Exp  RPAREN  {isBoolean($4.type);/*TODO WHILE BP*/} ScopeStart Statement ScopeEnd endWhile
			|	BREAK SC {if ((m_iWhileCounter) <= 0) {errorUnexpectedBreak(yylineno); exit(0);}/*TODO !.!*/}
			;
			
startWhile	: {m_iWhileCounter++;};
endWhile	: {m_iWhileCounter--;};

		
Call 		:	ID LPAREN ExpList RPAREN 
			{
				$$.type = validateAndGetTypeByName($1.name, false); validateCallFunction($1.name, funcCallTypes); funcCallTypes.clear();
				beforeFuncCall();
				storeValListInStack( usedRegsByExplist );
				usedRegsByExplist.clear();
				CodeBuffer::instance().emit("jal\t"+ $1.name + "\n");
			}

			|  	ID LPAREN RPAREN {$$.type = validateAndGetTypeByName($1.name, false); validateCallFunction($1.name, funcCallTypes); funcCallTypes.clear();	beforeFuncCall();CodeBuffer::instance().emit("jal\t"+ $1.name + "\n");}
			;
				
ExpList 	:	Exp {EXP_ATTRIBUTE symbol; symbol.type=$1.type; symbol.name=$1.name; funcCallTypes.push_back(symbol);$$.sizeForStack =1;usedRegsByExplist.push_back($1.resultReg);}
			|	Exp COMMA ExpList {EXP_ATTRIBUTE symbol; symbol.type=$1.type; symbol.name=$1.name; funcCallTypes.push_back(symbol);$$.sizeForStack = $3.sizeForStack+1;usedRegsByExplist.push_back($1.resultReg);}
			;
			
Type		:	INT		{ $$.type = Type_INT;}
			|	BYTE	{ $$.type = Type_BYTE;}
			|	BOOL	{ $$.type = Type_BOOL;};

			
Exp 		:	LPAREN Exp RPAREN {$$.type=$2.type; $$.trueList = $2.trueList; $$.falseList = $2.falseList;}
			|	ID LBRACK Exp RBRACK {$$.type=validateAndGetTypeByName($1.name, true); $$.name = $1.name; isIntOrByte($3.type); validateIsArray($1.name);}
			|	ID				
				{ 
					$$.type = validateAndGetTypeByName($1.name, true);
					$$.name = $1.name; $$.is_array = getIsArray($1.name); 
					loadValFromStack($1.name, $$);
				}
			|	Call			{ $$.type = $1.type;}
			|	NUM				{ $$.type = Type_INT; $$.num_value = $1.num_value; $$.resultReg = putNumInRegister($1.num_value);}
			| 	NUM B			{ checkByteSize($1.num_value,$1.name); $$.type = Type_BYTE; $$.num_value = $1.num_value; $$.resultReg = putNumInRegister($1.num_value);}
			| 	STRING			{ $$.type = Type_STRING;}
			|	TRUE			{ $$.type = Type_BOOL; $$.trueList = CodeBuffer::makelist(CodeBuffer::instance().emit("b "));}
			|	FALSE			{ $$.type = Type_BOOL; $$.falseList = CodeBuffer::makelist(CodeBuffer::instance().emit("b "));}
			|	Exp BINOP_1 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = getTypeBinop($1.type, $3.type); $$.resultReg = generateBinopRes1($2.name, $1, $3, $$.type);}
			|	Exp BINOP_2 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = getTypeBinop($1.type, $3.type); $$.resultReg = generateBinopRes2($2.name, $1, $3, $$.type);}
			|	Exp AND M Exp	{ isBoolean($1.type); isBoolean($4.type); $$.type = Type_BOOL;performAnd($$,$1,$4, $3);}
			|	Exp OR M Exp	{ isBoolean($1.type); isBoolean($4.type); $$.type = Type_BOOL;performOr($$,$1,$4, $3);}
			| 	Exp RELOP_1 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = Type_BOOL; createRelop($$, $1.resultReg, $3.resultReg, $2.name);}
			| 	Exp RELOP_2 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = Type_BOOL; createRelop($$, $1.resultReg, $3.resultReg, $2.name);}
			|	NOT Exp			{ isBoolean($2.type);  $$.type = Type_BOOL; $$.trueList = $2.falseList; $$.falseList = $2.trueList;}
			;

Exp_boolean	:   Exp {isBoolean($1.type);}
			;

ScopeStart	:	{start_Scope(); saveCurrentRegisterPool();}
			;
			
ProgramScopeStart	:	{ initRegisterPool(); program_scope_start();initCurrentRegisterPool(); }
			;
			
ScopeStartFunction	:	{start_scope_function();}
			;
		
ScopeEnd	:	{end_Scope(); loadRegisterPool();}
			;
ProgramScopeEnd	:	{end_Scope(); CodeBuffer::instance().printCodeBuffer();}
			;

M			:	{generateMMarker($$);}	
			;
N			:	{generateNMarker($$);}	
			;

%%

/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5*/

void handleBoolean(EXP_ATTRIBUTE& exp)
{
	int newReg = getFirstAvailableRegister();
	markRegisterUsed(newReg);
	string TRUELBL = CodeBuffer::instance().genLabel();
	CodeBuffer::instance().emit("li\t$" + intToString(newReg) + ", 1\n");
	int jmp = CodeBuffer::instance().emit("b ");
	string FALSELBL = CodeBuffer::instance().genLabel();
	CodeBuffer::instance().emit("li\t$" + intToString(newReg) + ", 0\n");
	string tar = CodeBuffer::instance().genLabel();
	CodeBuffer::instance().bpatch(CodeBuffer::instance().makelist(jmp), tar);
	CodeBuffer::instance().bpatch(exp.falseList, FALSELBL);
	CodeBuffer::instance().bpatch(exp.trueList, TRUELBL);
	
	exp.resultReg = newReg;
}

void createRelop(EXP_ATTRIBUTE& leftExp, int reg1, int reg2, string op)
{
	string sIfStatement = performRelop(reg1, reg2, op);
	int iNextInstruction1 = CodeBuffer::instance().emit(sIfStatement);
	leftExp.trueList = CodeBuffer::makelist(iNextInstruction1);
	
	int iNextInstruction2 = CodeBuffer::instance().emit("b ");
	leftExp.falseList = CodeBuffer::makelist(iNextInstruction2);
	
	markRegisterUnused(reg1);
	markRegisterUnused(reg2);
}

string performRelop(int reg1, int reg2, string op)
{
	string res = "";
	if (op.compare("==") == 0)
	{
		// beq	$t0,$t1,target	#  branch to target if  $t0 = $t1
		res += "beq\t";
	}
	else if (op.compare("!=") == 0)
	{
		// bne	$t0,$t1,target	#  branch to target if  $t0 <> $t1
		res += "bne\t";
	}
	else if (op.compare("<") == 0)
	{
		// blt	$t0,$t1,target	#  branch to target if  $t0 < $t1
		res += "blt\t";
	}
	else if (op.compare("<=") == 0)
	{
		// ble	$t0,$t1,target	#  branch to target if  $t0 <= $t1
		res += "ble\t";
	}
	else if (op.compare(">") == 0)
	{
		// bgt	$t0,$t1,target	#  branch to target if  $t0 > $t1
		res += "bgt\t";
	}
	else if (op.compare(">=") == 0)
	{
		// bge	$t0,$t1,target	#  branch to target if  $t0 >= $t1
		res += "bge\t";
	}
	
	res += "$" + intToString(reg1) + ", $" + intToString(reg2) + ", "; /// there's a blank here for the label inserted when backpatching
	return res;
}

void initRegisterPool()
{
	for(int i=0;i<26;i++)
		registerPool[i]=0;
}
void initCurrentRegisterPool()
{
	for(int i=0;i<26;i++)
		currentRegisterPool[i]=0;
}
void saveCurrentRegisterPool()
{
	for(int i=0;i<26;i++)
	currentRegisterPool[i]=registerPool[i];
}
void loadRegisterPool()
{
	for(int i=0;i<26;i++)
	registerPool[i]=currentRegisterPool[i];
}
void markAllRegisterPool()
{
	for(int i=0;i<26;i++)
		registerPool[i]=1;
}
int getFirstAvailableRegister()
{
	for(int i=8;i<26;i++)
	{
		if(registerPool[i]==0)
		{
			return i;
		}
	}
	return -1;
	
}

void markRegisterUnused(int iRegisterNumber)
{
	registerPool[iRegisterNumber] = 0;
}

void markRegisterUsed(int iRegisterNumber)
{
	registerPool[iRegisterNumber] = 1;
}
void performAnd(EXP_ATTRIBUTE& leftExp, EXP_ATTRIBUTE e1,EXP_ATTRIBUTE e2, EXP_ATTRIBUTE  M)
{
	CodeBuffer::instance().bpatch(e1.falseList,M.instr);
	leftExp.trueList = e2.trueList;
	leftExp.falseList = CodeBuffer::instance().merge(e1.falseList,e2.falseList);

}
void performOr(EXP_ATTRIBUTE& leftExp, EXP_ATTRIBUTE e1,EXP_ATTRIBUTE e2, EXP_ATTRIBUTE  M)
{
	CodeBuffer::instance().bpatch(e1.falseList, M.instr);
	leftExp.trueList = CodeBuffer::instance().merge(e1.trueList, e2.trueList);
	leftExp.falseList = e2.falseList;
}
int putNumInRegister(int num_value)
{
	int registerNum = getFirstAvailableRegister();	
	markRegisterUsed(registerNum);
	///li	$t1, 5	
	string toEmit = "li\t$" + intToString(registerNum) + ", " + intToString(num_value);
	
	CodeBuffer::instance().emit(toEmit);
	
	return registerNum;
}

int generateBinopRes2(string op, EXP_ATTRIBUTE b1, EXP_ATTRIBUTE b2, Type resType)
{
	int iB1Register = b1.resultReg;
	int iB2Register = b2.resultReg;
	
	int resRegister = getFirstAvailableRegister();
	markRegisterUsed(resRegister);
	
	if 		(op.compare("-") == 0) 
	{
		if (resType == Type_INT)
		{
			CodeBuffer::instance().emit(performSubInt_ResInResRegister(iB1Register, iB2Register, resRegister));
		}
		else
		{
			CodeBuffer::instance().emit(performSubByte_ResInResRegister(iB1Register, iB2Register, resRegister));
		}
	}
	else if (op.compare("+") == 0) 
	{
		if (resType == Type_INT)
		{
			CodeBuffer::instance().emit(performAddInt_ResInResRegister(iB1Register, iB2Register, resRegister));
		}
		else
		{
			CodeBuffer::instance().emit(performAddByte_ResInResRegister(iB1Register, iB2Register, resRegister));
		}
	}

	if(resType==Type_BYTE)
	{
		//handling bool overflow- truncating it with a mask, so result is in range 0-255
		CodeBuffer::instance().emit("and\t"+intToString(iB1Register) + ", " +intToString(iB1Register)+ " , 0x000000ff\n");
	}
	
	markRegisterUnused(iB1Register);
	markRegisterUnused(iB2Register);
	//// could be optimized to use B1 again as result register
	
	return resRegister;
}

string performSubByte_ResInResRegister(int iB1Register, int iB2Register, int resRegister)
{
	//addu	$t1,$t6,$t7
	return "subu\t$" + intToString(resRegister) + ", $" + intToString(iB1Register) + ", $" + intToString(iB2Register) + "\n";
}

string performSubInt_ResInResRegister(int iB1Register, int iB2Register, int resRegister)
{
	//addu	$t1,$t6,$t7
	return "sub\t$" + intToString(resRegister) + ", $" + intToString(iB1Register) + ", $" + intToString(iB2Register) + "\n";
}

string performAddInt_ResInResRegister(int iB1Register, int iB2Register, int resRegister)
{
	//addu	$t1,$t6,$t7
	return "add\t$" + intToString(resRegister) + ", $" + intToString(iB1Register) + ", $" + intToString(iB2Register) + "\n";
}

string performAddByte_ResInResRegister(int iB1Register, int iB2Register, int resRegister)
{
	//addu	$t1,$t6,$t7
	return "addu\t$" + intToString(resRegister) + ", $" + intToString(iB1Register) + ", $" + intToString(iB2Register) + "\n";
}


int generateBinopRes1(string op, EXP_ATTRIBUTE b1, EXP_ATTRIBUTE b2,Type resType)
{
	int iB1Register = b1.resultReg;
	int iB2Register = b2.resultReg;

	if (op.compare("/") == 0)
	{
		CodeBuffer::instance().emit(performDiv_ResInB1(iB1Register, iB2Register));
	}
	else if (op.compare("*") == 0) {
		int areBothByte=0;
		if(resType==Type_BYTE)
		{
			areBothByte=1;
		}
		CodeBuffer::instance().emit(performMul_ResInB1(iB1Register, iB2Register,areBothByte));
	}
	
	markRegisterUnused(iB2Register);
	
	return iB1Register;
	//// result in iB1Register
}
int getOffset(string name)
{
	T_Symbol symb=getSymbol(name);
	if(symb.type == __Type_INVALID )
	{
		errorUndef(yylineno, name);
		exit(0);
	}
	return symb.offset;
}
string performMul_ResInB1(int iB1Register, int iB2Register, int areBothByte)
{
	
	string res = "mult\t$" + intToString(iB1Register) + ", $" + intToString(iB2Register) + "\n";
	res += "mflo\t$" + intToString(iB1Register);

	if(areBothByte==1)
	{
		//handling bool overflow- truncating it with a mask, so result is in range 0-255
		CodeBuffer::instance().emit("and\t"+intToString(iB1Register) + ", " +intToString(iB1Register)+ " , 0x000000ff\n");
	}
	return res;
}

string performDiv_ResInB1(int iB1Register, int iB2Register)
{
	int tmpReg=getFirstAvailableRegister();



	//TODO: put in func
	markRegisterUsed(tmpReg);
	
	CodeBuffer::instance().emit("li\t" + intToString(tmpReg) + " , 1\n");
	CodeBuffer::instance().emit("bne\t"+intToString(tmpReg) + ", " + intToString(iB2Register) + ", throwDivException\n");
	markRegisterUnused(tmpReg);
	//TODO: put in func



	string res = "div\t$" + intToString(iB1Register) + ", $" + intToString(iB2Register) + "\n";
	res += "mflo\t$" + intToString(iB1Register);
	return res;
}

string intToString(int theInt)
{
	ostringstream stream;
	stream << theInt;
	return stream.str();
}

void generateMMarker(EXP_ATTRIBUTE& exp)
{
	exp.instr=CodeBuffer::instance().genLabel();
}

void generateNMarker(EXP_ATTRIBUTE& exp)
{
	exp.nextList=CodeBuffer::makelist(CodeBuffer::instance().emit("b "));
}

void saveAllRegisters()
{
	CodeBuffer::instance().emit("addi $sp , $sp,-72\n");

	for(int i=0;i<18;i++)
	{
		ostringstream ss;
		ss<< i*VAR_SIZE;
		CodeBuffer::instance().emit("sw\t$"  + intToString(i+8) +", " + ss.str()+  "($sp)\n");
	}
	initRegisterPool();//they are saved, so now they are all free to use!
	
}

void loadAllRegisters()
{
	for(int i=0;i<18;i++)
	{
		ostringstream ss;
		ss<< i*VAR_SIZE;
		CodeBuffer::instance().emit("lw\t$" + intToString(i+8) + "," +ss.str()+  "($sp)\n");
	}
	CodeBuffer::instance().emit("addi $sp , $sp,72\n");

	
}

void storeValInStack(string variable, int iRegisterNumber)
{
	int posOfVar=getOffset(variable);	//TODO- make sure its correct
	int offsetFromFP = -posOfVar*VAR_SIZE;
	ostringstream ss;
	ss << offsetFromFP;
	CodeBuffer::instance().emit("sw\t$" + intToString(iRegisterNumber) + ", " +ss.str()+"($fp)\n");
	markRegisterUnused(iRegisterNumber);
}

void loadValFromStack(string variable, EXP_ATTRIBUTE& leftExp)
{
	T_Symbol symb=getSymbol(variable);

	int posOfVar=symb.offset;	//TODO- make sure its correct
	int offsetFromFP = -posOfVar*VAR_SIZE;
	int iDestRegister = getFirstAvailableRegister();
	markRegisterUsed(iDestRegister);

	if (symb.type == Type_BOOL)
	{
		int iRegister = getFirstAvailableRegister();
		markRegisterUsed(iRegister);
		CodeBuffer::instance().emit("li\t$" + intToString(iRegister) +", 1\n");
		createRelop(leftExp, iRegister, iDestRegister,"==");
		/// TODO: idest register is unused, remove next line
		iDestRegister = 25;
	}
	
	ostringstream ss;
	ss << offsetFromFP;
	CodeBuffer::instance().emit("lw\t$" + intToString(iDestRegister) + ", " +ss.str()+"($fp)\n");
	leftExp.resultReg=iDestRegister;
}

void addPrintHelper()
{
	CodeBuffer::instance().emit("lw\t$a0,0($sp)\n");
	CodeBuffer::instance().emit("li\t$v0,4\n");
	CodeBuffer::instance().emit("syscall\n");
	CodeBuffer::instance().emit("add\t$sp, $fp, 8\n");
	CodeBuffer::instance().emit("lw\t$ra, 0($sp)\n");
	CodeBuffer::instance().emit("lw\t$fp, 4($sp)\n");
	CodeBuffer::instance().emit("add\t$sp, $sp, 8\n");
}
void addPrintiHelper()
{
	CodeBuffer::instance().emit("lw\t$a0,0($sp)\n");
	CodeBuffer::instance().emit("li\t$v0,1\n");
	CodeBuffer::instance().emit("syscall\n");
	CodeBuffer::instance().emit("add\t$sp, $fp, 8\n");
	CodeBuffer::instance().emit("lw\t$ra, 0($sp)\n");
	CodeBuffer::instance().emit("lw\t$fp, 4($sp)\n");
	CodeBuffer::instance().emit("add\t$sp, $sp, 8\n");
}

void initializeStackFP()
{
	CodeBuffer::instance().emit("addi $fp, $sp, -4\n");
}
void storeValListInStack( vector<int> values)
{
	int offset = values.size()*VAR_SIZE; 
	ostringstream ss;
	ostringstream ss2;
	ss << offset;
	CodeBuffer::instance().emit("add $sp , $sp , -"+ ss.str() +"\n");

	for(int i =0;i<values.size();i++)
	{		
		ss2 << VAR_SIZE*i;
		CodeBuffer::instance().emit("sw\t$" +intToString(values[values.size() - i -1]) +", " + ss2.str() +"($sp)\n");
		markRegisterUnused(values[values.size() -i -1]);
	}

}
void storeFuncRetAddrInStack(int numOfArgs)
{	
	int offset = (numOfArgs)*VAR_SIZE;
	ostringstream sstr;
	sstr << offset;
	CodeBuffer::instance().emit("sw\t$ra , "+ sstr.str()+"($sp)");
	//TODO: find out numOfArgs
}
void addPrintFunc(){
	//TODO: use this and addprinti when starting the program
	CodeBuffer::instance().emit("print:");
	initializeStackFP();
	storeFuncRetAddrInStack(1);
	addPrintHelper();
	loadAllRegisters();
	CodeBuffer::instance().emit("jr\t$ra\n");
}
void addPrintiFunc()
{	
	CodeBuffer::instance().emit("printi:");
	initializeStackFP();
	storeFuncRetAddrInStack(1);
	addPrintiHelper();
	loadAllRegisters();
	CodeBuffer::instance().emit("jr\t$ra\n");
}
void beforeFuncCall()
{
	//save mr register:
	saveAllRegisters();

	//move sp down to add a slot for the return address and FP
	CodeBuffer::instance().emit("addi\t$sp, $sp, -8\n");
	//put the return address on the stack in that spot we just allocated
	CodeBuffer::instance().emit("sw\t$fp, 4($sp)\n");
	//todo- check if its working


	return;
}
void popStackAfterFunction (int size)
{	
	ostringstream ss;
	ss << VAR_SIZE*(size+1);
	CodeBuffer::instance().emit("addi\t$sp, $fp, " + ss.str()+"\n");
	CodeBuffer::instance().emit("lw\t$ra, 0($sp)\n");
	CodeBuffer::instance().emit("lw\t$fp, 4($sp)\n");
	CodeBuffer::instance().emit("addi\t$sp, $sp, 8\n");
	loadAllRegisters();
}
void bpIF2Statement(EXP_ATTRIBUTE& S,EXP_ATTRIBUTE B, EXP_ATTRIBUTE M1, EXP_ATTRIBUTE M2, EXP_ATTRIBUTE S1, EXP_ATTRIBUTE N, EXP_ATTRIBUTE S2)
{
	CodeBuffer::instance().bpatch(B.trueList,M1.instr);
	CodeBuffer::instance().bpatch(B.falseList,M2.instr);
	vector<int> temp= CodeBuffer::instance().merge(S1.nextList,N.nextList);
	S.nextList=CodeBuffer::instance().merge(temp,S2.nextList);	
}
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5*/

void validateIsArray(string name)
{
	if (!getIsArray(name))
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

void checkRHSNotArray(bool is_array)
{
	if (is_array)
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

bool getIsArray(string name)
{
	T_Symbol symbol=getSymbol(name);
	if(symbol.type != __Type_INVALID) // should always be defined but still
	{
		return symbol.Type_ARRAY_SIZE != -1;
	}
}

void validateFunctionArg(string varName)
{
	T_Symbol symbol=getSymbol(varName);
	if(symbol.type != __Type_INVALID)
	{
		if(symbol.isFunction)
		{
			errorDef(yylineno, varName);
			exit(0);
		}
	}
}

void validateCallFunction(string funcName, vector<EXP_ATTRIBUTE> callArgs)
{
	//cout << "validating " << funcName << endl;
	T_Symbol symbFunc=getSymbol(funcName);
	if(symbFunc.type == __Type_INVALID || !symbFunc.isFunction)
	{
		errorUndefFunc(yylineno, funcName);
		exit(0);
	}
	if (symbFunc.lstArgs.size() != callArgs.size())
	{
		//cout << "args list size is different, got " << callArgs.size() << endl;
		vector<string> lstStringArgs = generateStringTypes(symbFunc.lstArgs);
		errorPrototypeMismatch(yylineno, funcName, lstStringArgs);
		exit(0);
	}
	int i = 0;
	for (list<T_Symbol>::reverse_iterator it=symbFunc.lstArgs.rbegin(); it!=symbFunc.lstArgs.rend(); ++it)
	{
		T_Symbol currSymbol = *it;
		//cout << "currSymbol name: " << currSymbol.name << ", type is: " << currSymbol.type << endl;
		//cout << "args[i] is: " << callArgs[i].name << endl;
		//cout << "currSymbol.type " << (int)currSymbol.type << " callArgs[i].type" << (int)callArgs[i].type << endl;
		if (currSymbol.type != callArgs[i].type)
		{
			if (!(currSymbol.type == Type_INT && callArgs[i].type == Type_BYTE))
			{
				vector<string> lstStringArgs = generateStringTypes(symbFunc.lstArgs);
				errorPrototypeMismatch(yylineno, funcName, lstStringArgs);
				exit(0);
			}	
		}
		else 
		{
			if (currSymbol.Type_ARRAY_SIZE != -1)
			{
				T_Symbol argSymb = getSymbol(callArgs[i].name);
				if (argSymb.type != __Type_INVALID)
				{
					if (argSymb.Type_ARRAY_SIZE != -1)
					{
						if (argSymb.Type_ARRAY_SIZE != currSymbol.Type_ARRAY_SIZE)
						{
							vector<string> lstStringArgs = generateStringTypes(symbFunc.lstArgs);
							errorPrototypeMismatch(yylineno, funcName, lstStringArgs);
							exit(0);
						}
					}
					else
					{
						vector<string> lstStringArgs = generateStringTypes(symbFunc.lstArgs);
						errorPrototypeMismatch(yylineno, funcName, lstStringArgs);
						exit(0);
					}
				}
				else
				{
					vector<string> lstStringArgs = generateStringTypes(symbFunc.lstArgs);
					errorPrototypeMismatch(yylineno, funcName, lstStringArgs);
					exit(0);
				}
			}
		}
		i++;
	}
	
}

void checkHasMain()
{
	string sMainFuncName = "main";
	T_Symbol mainFunc=getSymbol(sMainFuncName);
	if(mainFunc.type != __Type_INVALID)
	{
		if(mainFunc.isFunction && mainFunc.type == Type_VOID)
		{
			if (mainFunc.lstArgs.empty())
			{
				return;
			}
		}
	}
	errorMainMissing();	
	exit(0);
}

void program_scope_start()
{
	start_Scope();
	
	T_Symbol stringSymbol;
	stringSymbol.type = Type_STRING;
	list<T_Symbol> lstArgs2;
	lstArgs2.push_back(stringSymbol);
	addFunctionToSymbolTable("print", Type_VOID, lstArgs2);
	
	T_Symbol integerSymbol;
	integerSymbol.type = Type_INT;
	list<T_Symbol> lstArgs1;
	lstArgs1.push_back(integerSymbol);
	addFunctionToSymbolTable("printi", Type_VOID, lstArgs1);

}

void addFunctionToSymbolTable(string name, Type returnType, list<T_Symbol> args)
{
	T_Symbol funcSymbol;
	funcSymbol.isFunction = true;
	funcSymbol.name = name;
	funcSymbol.type = returnType;

	for (list<T_Symbol>::iterator it=args.begin(); it!=args.end(); ++it) 
	{
		T_Symbol symbol = *it;
		funcSymbol.lstArgs.push_back(symbol);
	}

	m_stScopeStack.front().addSymbol(funcSymbol);
}

void validateArraySize(int numValue, string name)
{
	if (numValue <= 0 || numValue >= 256)
	{
		errorInvalidArraySize(yylineno, name);
		exit(0);
	}
}

Type validateAndGetTypeByName(string name, bool isVariable)
{
	for (list<SymbolTable>::iterator it_st=m_stScopeStack.begin(); it_st!=m_stScopeStack.end(); ++it_st)
	{
		SymbolTable& currentTable = *it_st;
		if (currentTable.lstSymbols.size() > 0) {
			for (list<T_Symbol>::iterator it=currentTable.lstSymbols.begin(); it!=currentTable.lstSymbols.end(); ++it)
			{
				T_Symbol curr = *it;
				if(name == curr.name)
				{
					return curr.type;
				}
			}
			
		}
	}
	
	if(isVariable==true)
	{
		errorUndef(yylineno, name);	
	}
	else
	{
		errorUndefFunc(yylineno, name);
	}	
	exit(0);
	return (Type) -1;
}

Type getTypeBinop(Type t1, Type t2)
{
	if (t1 == t2)
	{
		//cout << "binop type is: " << t1 << endl;
		return t1;
	}
	//cout << "binop type is: " << Type_INT << endl;
	return Type_INT;
}

void isBoolean(Type t)
{
	
	if (t != Type_BOOL)
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

void isIntOrByte(Type t)
{
	//cout << "t type: " << t << endl;
	if (t != Type_INT && t != Type_BYTE)
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

void validateAssignmentDynamic(string lhsName, string rhsName, Type rhsType, bool rhs_is_array)
{
	
	T_Symbol lhsSymbol=getSymbol(lhsName);
	if(lhsSymbol.type == __Type_INVALID)
	{
		//should never reach here because we called validateDefined on the lhs symbol before this func

		//you called the wrong error again! i fixed it.
		
		errorUndef(yylineno, lhsName);	
		exit(0);
	}

	T_Symbol rhsSymbol=getSymbol(rhsName);
	
	if (lhsSymbol.Type_ARRAY_SIZE != -1)
	{
		/// lhs is an array
		
		if(rhsSymbol.type == __Type_INVALID) 
		{
			///rhs is not even a variable
			
			errorMismatch(yylineno);
			exit(0);
			return;
		}

		if (rhsSymbol.Type_ARRAY_SIZE != lhsSymbol.Type_ARRAY_SIZE)
		{
			
			errorMismatch(yylineno);
			exit(0);
		}
		///both are arrays from same size!
		
		if (rhsSymbol.type != lhsSymbol.type)
		{
			
			errorMismatch(yylineno);
			exit(0);
		}
		
		if(!rhs_is_array)
		{		
			 errorMismatch(yylineno);
			 exit(0);
		}
		
		
		///both are arrays from same size and type! SUCCESS
	}
	else /// lhs is not an array
	{
		if(rhs_is_array) 
		{
			
			errorMismatch(yylineno);
			exit(0);
			return;
		}
		validateAssignment(lhsSymbol.type, rhsType);
	}
}

void validateAssignment(Type lhs, Type rhs)
{
	

	if (lhs != rhs)
	{
		if (lhs == Type_INT && rhs == Type_BYTE)
		{
			return;
		}		
		errorMismatch(yylineno);
		exit(0);
	}
}

void start_Scope()
{
	SymbolTable newTable;
	m_stScopeStack.push_front(newTable);
	
}
bool contains(list<T_Symbol> lstStrings, string sym)
{
	vector<string> vec;
	for (list<T_Symbol>::iterator it=lstStrings.begin(); it!=lstStrings.end(); ++it) 
	{
		T_Symbol currSym = *it;
		vec.push_back(currSym.name);
	}
	return find(vec.begin(), vec.end(), sym) != vec.end();
}

void createFunctionObj(string name, Type type)
{
	list<T_Symbol> lstArgsTmp;
	
	for (list<T_Symbol>::iterator it=funcArgs.begin(); it!=funcArgs.end(); ++it) 
	{
		T_Symbol symbol = *it;

		validateFunctionArg(symbol.name);
		if (symbol.name.compare(name) == 0)
		{
			///current function arg has same name as function
			errorDef(yylineno, symbol.name);	
			exit(0);
		}
		if(contains(lstArgsTmp,symbol.name))
		{
			//2 function args with same name
			errorDef(yylineno, symbol.name);	
			exit(0);
		}		
		lstArgsTmp.push_back(symbol);
	}
	
	addFunctionToSymbolTable(name, type, lstArgsTmp);
}


void checkFuncValidReturn(Type type,int size, bool return_value_is_array)
{
	if (return_value_is_array)
	{
		errorMismatch(yylineno);
		exit(0);
	}

	for (list<SymbolTable>::iterator it_st=m_stScopeStack.begin(); it_st!=m_stScopeStack.end(); ++it_st)
	{
		SymbolTable& currentTable = *it_st;
		if (currentTable.lstSymbols.size() > 0)
		 {
			for (list<T_Symbol>::reverse_iterator it=currentTable.lstSymbols.rbegin(); it!=currentTable.lstSymbols.rend(); ++it)
			{
				T_Symbol curr = *it;
				if(curr.isFunction)
				{
					if(curr.type!=type && !(type == Type_BYTE && curr.type == Type_INT))
					{
						//cout<<"fun type: "<<curr.type << " type: "<< type;
						errorMismatch(yylineno);
						exit(0);
					}
					//its ok-finish
					return;
				}
			}
			
		}
	}


	// errorMismatch(yylineno);
	// exit(0);




}
void start_scope_function()
{
	SymbolTable newTable;
	for (list<T_Symbol>::iterator it=funcArgs.begin(); it!=funcArgs.end(); ++it) 
	{
		T_Symbol symbol = *it;
		//cout << "adding symbol: " << symbol.name << endl;
		newTable.addSymbol(symbol);
	}
	m_stScopeStack.push_front(newTable);
}

void end_Scope()
{
	int variablesCounter=0;
	SymbolTable& top = m_stScopeStack.front();
	endScope();
	if (top.lstSymbols.size() > 0) {
		for (list<T_Symbol>::iterator it=top.lstSymbols.begin(); it!=top.lstSymbols.end(); ++it) {
			T_Symbol curr = *it;
			

			
			if (curr.isFunction)
			{
				vector<string> lstArgsAsStrings = generateStringTypes(curr.lstArgs);
				//cout << "function type is: " << TYPES_TO_STRING[curr.type] << endl;
				string sFunctionType = makeFunctionType(TYPES_TO_STRING[curr.type], lstArgsAsStrings);
				printID(curr.name, 0, sFunctionType);
			}
			else
			{
				

				if (curr.Type_ARRAY_SIZE != -1)
				{
					variablesCounter+=curr.Type_ARRAY_SIZE;//TODO:make sure its the correct size
					string sArrayType = makeArrayType(TYPES_TO_STRING[curr.type], curr.Type_ARRAY_SIZE);
					printID(curr.name, curr.offset, sArrayType);
					//cout <<"curr name: "<<curr.name<< "curr offset: " << m_iCurrentOffset << "calling -arraysize"<< endl;

					if(curr.offset>=0)
						m_iCurrentOffset-=curr.Type_ARRAY_SIZE;
				}
				else
				{
					printID(curr.name, curr.offset, TYPES_TO_STRING[curr.type]);
					variablesCounter++;
					//cout <<"curr name: "<<curr.name<< "curr offset: " << m_iCurrentOffset << "calling --" <<endl;
					if(curr.offset>=0)
						m_iCurrentOffset--;				
					
				}

				
			}
		}
	}
	ostringstream ss;
	ss << VAR_SIZE* variablesCounter;
	//popping the scope stack:

	CodeBuffer::instance().emit("add\t$sp, $sp, " + ss.str()) + "\n";	
	m_stScopeStack.pop_front();
}

vector<string> generateStringTypes(list<T_Symbol> lstArgs)
{
	vector<string> lstArgsAsStrings;
	for (list<T_Symbol>::iterator it=lstArgs.begin(); it!=lstArgs.end(); ++it) 
	{
		T_Symbol symbol = *it;
		if (symbol.Type_ARRAY_SIZE != -1)
		{
			string sArrayType = makeArrayType(TYPES_TO_STRING[symbol.type], symbol.Type_ARRAY_SIZE);
			lstArgsAsStrings.push_back(sArrayType);
		}
		else
		{
			lstArgsAsStrings.push_back(TYPES_TO_STRING[symbol.type]);
		}
	}
	return lstArgsAsStrings;
}

void validateNotAlreadyDefined(string name)
{
	//cout << " name is: " << name << endl;
	T_Symbol result=getSymbol(name);
	if(result.type!=__Type_INVALID)
	{
		//if type is not invalid, symbol exists
		//, bad.
		errorDef(yylineno, name);	
		exit(0);
	}	
	
}


//will return error if its not defined. 
void validateDefined(string name, bool isVariable) 
{
	T_Symbol result=getSymbol(name);
	if(result.type==__Type_INVALID)
	{
		//doesnt exist, return error
		if(isVariable==true)
		{
			errorUndef(yylineno, name);	
		}
		else
		{
			errorUndefFunc(yylineno, name);
		}		
		exit(0);
	}
	if (result.isFunction == true &&  isVariable == true)
	{
		errorUndef(yylineno, name);	
		exit(0);
	}

}

T_Symbol createFunctionSymbol(string name, Type type, int size)
{
	//cout << "createFunctionSymbol called with name: " << name << endl;
	T_Symbol symbol;
	symbol.name = name;
	symbol.type = type;
	
	if(size>-1)//its an array!
	{
		symbol.Type_ARRAY_SIZE=size;		
		m_iFUNCTION_CurrentOffset-=(size-1);
	}

	symbol.offset = m_iFUNCTION_CurrentOffset--;
	
	return symbol;
}

int getExpSizeFromTable(string name)
{
	T_Symbol sym=getSymbol(name);
	return sym.Type_ARRAY_SIZE;
}



void createAndPushSymbol(string name, Type type, int size)
{
	//cout << "creating symbol with name: " << name << " in line: " << yylineno << endl;
	
	T_Symbol symbol;
	symbol.name = name;
	symbol.type = type;
	//cout <<"curr name: "<<symbol.name<< "curr offset: " << m_iCurrentOffset << "calling ++"<< endl;

	symbol.offset = m_iCurrentOffset++;
	symbol.Type_ARRAY_SIZE=-1;//redundant, taken care of in constructor

	//adding slot for it in the stack
	CodeBuffer::instance().emit("addi\t$sp, $sp, -4\n");	

	/////init///
	CodeBuffer::instance().emit("sw\t$0, ($sp)\n");
	//// end init ///

	if(size>-1)//its an array!
	{
		//cout <<"curr name: "<<symbol.name<< "curr offset: " << m_iCurrentOffset << "calling +arraysize"<< endl;
		symbol.Type_ARRAY_SIZE=size;		
		m_iCurrentOffset+=size-1;

		//adding additional slots for the array elements on the stack
		CodeBuffer::instance().emit("addi\t$sp, $sp, -" + intToString((size-1)*VAR_SIZE)+ "\n");
		for(int i =0;i<size;i++)
		{
			ostringstream ss;
			ss << VAR_SIZE*i;
			CodeBuffer::instance().emit("sw\t$0, " + ss.str() +"($sp)\n");
		}
	}

	m_stScopeStack.front().addSymbol(symbol);
}


T_Symbol getSymbol(string name)
{
//if the element doesnt exist, returns a symbol with __Type_INVALID type
	for (list<SymbolTable>::iterator it_st=m_stScopeStack.begin(); it_st!=m_stScopeStack.end(); ++it_st)
	{
		SymbolTable& currentTable = *it_st;
		if (currentTable.lstSymbols.size() > 0) {
			for (list<T_Symbol>::iterator it=currentTable.lstSymbols.begin(); it!=currentTable.lstSymbols.end(); ++it)
			{
				T_Symbol curr = *it;
				if(name.compare(curr.name) == 0)
				{
					return curr;
				}
			}
			
		}
	}


	T_Symbol symbol;
	symbol.type=__Type_INVALID;
	symbol.name = "__bad__";
	symbol.Type_ARRAY_SIZE=-1;	
	return symbol;
}


void checkByteSize(int value, string valueInStringForm)
{
	if(value>255) 
	{
		errorByteTooLarge(yylineno,valueInStringForm); 
		exit(0);
	}

}


int main()
{	TYPES_TO_STRING.push_back("INT");
	TYPES_TO_STRING.push_back("BYTE");
	TYPES_TO_STRING.push_back("STRING");
	TYPES_TO_STRING.push_back("VOID");
	TYPES_TO_STRING.push_back("BOOL");
	yyparse();
}

int yyerror(const char * message)
{
	errorSyn(yylineno);
	///maybe pop stack here
	exit(0);
}