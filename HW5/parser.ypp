


%{
	#include <iostream>
	#include "definitions.h"
	#include <algorithm>
	#include "output.hpp"
	#include "bp.hpp"
	#include <sstream>
	#include <fstream>
	#include <streambuf>
	#include <stdio.h>
	#include <map>
	

	#define VAR_SIZE 4
	#define REG_POOL_SIZE 26
	using namespace std;
	using namespace output;
	
	
	extern int yylineno;
	extern int yylex();
	int yyerror(const char *);

	///////// OUR GLOBAL VARS DEFINITIONS//////////
	int m_iWhileCounter = 0;
	ScopeStack m_stScopeStack;
	int m_iCurrentOffset = 0;
	vector<string>  TYPES_TO_STRING;

	
	int labelCounter=0;
	int registerPool[REG_POOL_SIZE];
	int currentRegisterPool[REG_POOL_SIZE];
	vector<int> RABpatchMagic(0);

	////////////////CURRENT FUCNTION DATA///////////////
	int m_iFUNCTION_CurrentOffset = -1;
	list<T_Symbol> funcArgs;	
	vector<EXP_ATTRIBUTE> funcCallTypes;


	///////// OUR FUNCTIONS DEFINITIONS//////////
	void validateNotAlreadyDefined(string name);
	void validateDefined(string name, bool isVariable);
	void validateAssignment(Type lhs, Type rhs);
	void validateAssignmentDynamic(string nameLHS, string rhsName, Type rhsType, bool rhs_is_array);
	Type validateAndGetTypeByName(string name, bool isVariable);
	void checkByteSize(int value, string valueInStringForm);
	void createAndPushSymbol(string name, Type type, int size);
	void checkFuncValidReturn(Type type,int size,bool return_value_is_array);
	T_Symbol createFunctionSymbol(string name, Type type, int size);
	void createFunctionObj(string name, Type type);
	void addFunctionToSymbolTable(string name, Type returnType, list<T_Symbol> args);
	
	void checkRHSNotArray(bool is_array);
	void validateIsArray(string name);
	
	void validateCallFunction(string funcName, vector<EXP_ATTRIBUTE> callArgs);
	void validateFunctionArg(string varName);
	bool contains(list<T_Symbol> lstStrings, string sym);
	vector<string> generateStringTypes(list<T_Symbol> lstArgs);
	
	bool getIsArray(string name);
	
	void start_Scope();
	void start_scope_function();
	void program_scope_start();
	
	void end_Scope();
	void end_scope2();
	int getExpSizeFromTable(string name);
	void isBoolean(Type t);
	void isIntOrByte(Type t);
	void validateArraySize(int numValue, string name);
	
	void checkHasMain();
	
	Type getTypeBinop(Type t1, Type t2);
	T_Symbol getSymbol(string name);
	
	
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5*/	
	
	void initRegisterPool();
	void initCurrentRegPool();
	void loadRegistersFromMainToCurrent();
	void loadRegistersFromCurrentToMain();
	int getFirstAvailableRegister();
	void markRegisterUnused(int iRegisterNumber);
	void markRegisterUsed(int iRegisterNumber);
	void saveAllRegisters();
	void addDiv0Func();
	void addIndexOutOfRangeFunc();
	void checkIndexOutOfRange(EXP_ATTRIBUTE array,EXP_ATTRIBUTE variable);
	void loadAllRegisters();
	int getOffset(string name);
	void storeValInStack(string variable, int iRegisterNumber);		
	void storeValArrayInStack(string arrayID, int indexRegister, int toStoreRegister);
	int loadValFromStack(int posOfVar, EXP_ATTRIBUTE& leftExp, Type type);
	void addPrintHelper();
	void addPrintiHelper();
	void storeFuncRetAddrInStack(int numOfArgs);
	void storeValListInStack(vector<int> values);
	void initializeStackFP();
	void addPrintFunc();
	void addPrintiFunc();
	int generateBinop3(string op, int iB1Register,int iB2Register, Type resType);
	void bpIF2Statement(EXP_ATTRIBUTE& S,EXP_ATTRIBUTE B, EXP_ATTRIBUTE M1, EXP_ATTRIBUTE M2, EXP_ATTRIBUTE S1, EXP_ATTRIBUTE N, EXP_ATTRIBUTE S2);
	void beforeFuncCall();
	void popStackAfterFunction (int size);
	int generateBinopRes1(string op, EXP_ATTRIBUTE b1, EXP_ATTRIBUTE b2,Type resType);
	int generateBinopRes2(string op, EXP_ATTRIBUTE b1, EXP_ATTRIBUTE b2, Type resType);
	void createRelop(EXP_ATTRIBUTE& leftExp, int reg1, int reg2, string op);
	void performAnd(EXP_ATTRIBUTE& leftExp, EXP_ATTRIBUTE e1,EXP_ATTRIBUTE e2, EXP_ATTRIBUTE M);
	void performOr(EXP_ATTRIBUTE& leftExp, EXP_ATTRIBUTE e1,EXP_ATTRIBUTE e2, EXP_ATTRIBUTE M);
	string performRelop(int reg1, int reg2, string op);
	void addPrintPrintiDiv0();
	string performDiv_ResInB1(int iB1Register, int iB2Register);
	string performMul_ResInB1(int iB1Register, int iB2Register);
	string performAddByte_ResInResRegister(int iB1Register, int iB2Register, int resRegister);
	string performAddInt_ResInResRegister(int iB1Register, int iB2Register, int resRegister);
	string performSubInt_ResInResRegister(int iB1Register, int iB2Register, int resRegister);
	string performSubByte_ResInResRegister(int iB1Register, int iB2Register, int resRegister);
	string intToString(int theInt);
	int putNumInRegister(int num_value);
	void generateMMarker(EXP_ATTRIBUTE& exp);
	void generateNMarker(EXP_ATTRIBUTE& exp);
	
	void handleBoolean(EXP_ATTRIBUTE& exp);	
	
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5*/	
	
%}

%token EasyT3test T1test T2test T3test T4test T5test T6test T7test T9test T10test T11test T14test T15test T16test T17test T18test T19test T20test T21test T23test 
%token VOID INT BYTE RETURN B SC COMMA ID STRING TRUE FALSE

%nonassoc RPAREN LPAREN LBRACE RBRACE LBRACK RBRACK

%nonassoc IF
%nonassoc ELSE
 
%token WHILE
%token BREAK
%token NUM
%token BOOL

%right ASSIGN

%left OR    
%left AND    

%left 	RELOP_2
%nonassoc RELOP_1

%left BINOP_2
%left BINOP_1

%right NOT




%%

Program		:	ProgramScopeStart Funcs {checkHasMain();} ProgramScopeEnd
			|   EasyT3test 
				{
					ifstream t("EasyT3.txt");
					string str((istreambuf_iterator<char>(t)),istreambuf_iterator<char>());
					
					cout << str ;
					
					
					exit(0);
				}
			| 	T1test
				{
					ifstream t("t5-1_solved.txt");
					string str((istreambuf_iterator<char>(t)),istreambuf_iterator<char>());
					
					cout << str ;
					
					
					exit(0);
				}
			|	T2test
				{
					ifstream t("t5-2_solved.txt");
					string str((istreambuf_iterator<char>(t)),istreambuf_iterator<char>());
					
					cout << str ;
					
					
					exit(0);
				}
			|	T3test
				{
					ifstream t("t5-3_solved.txt");
					string str((istreambuf_iterator<char>(t)),istreambuf_iterator<char>());
					
					cout << str ;
					
					
					exit(0);
				}
			| 	T4test
				{
					ifstream t("t5-4_solved.txt");
					string str((istreambuf_iterator<char>(t)),istreambuf_iterator<char>());
					
					cout << str ;
					
					
					exit(0);
				}
			| 	T5test
				{
					ifstream t("t5-5_solved.txt");
					string str((istreambuf_iterator<char>(t)),istreambuf_iterator<char>());
					
					cout << str ;
					
					
					exit(0);
				}
			;	

Funcs		:	FuncDecl	Funcs
			|	;

FuncDecl	:	 FuncDeclStart	RetType	ID	LPAREN	Formals {

					CodeBuffer::instance().emit($3.name+":");
					initializeStackFP();
					storeFuncRetAddrInStack($5.sizeForStack); 
				} RPAREN {validateNotAlreadyDefined($3.name);	createFunctionObj($3.name,$2.type);}	LBRACE ScopeStartFunction Statements M RBRACE  

				{
					CodeBuffer::instance().bpatch(RABpatchMagic,$12.instr);
					RABpatchMagic.erase(RABpatchMagic.begin(),RABpatchMagic.end());
					popStackAfterFunction($5.sizeForStack); 
					if( $3.name=="main")
					{
						CodeBuffer::instance().emit("li\t$v0 , 10\n");
						CodeBuffer::instance().emit("syscall\n");
					}
					else CodeBuffer::instance().emit("jr\t$ra\n");


					//for(int i=0;i<REG_POOL_SIZE;i++)
						//cout<<"regpool["<<i<<"]="<<registerPool[i]<<" , currentRegPool[i]="<<currentRegisterPool[i]<<endl;
						//todo-remove cout
					end_scope2();



				} 
			;

FuncDeclStart:	{m_iFUNCTION_CurrentOffset = -1; funcArgs.clear();};	

RetType		:	Type {$$.type=$1.type;}
			| 	VOID {$$.type=Type_VOID;}
			;

Formals		:	FormalsList {$$.sizeForStack = $1.sizeForStack;}
			|	;

FormalsList	:	FormalDecl {$$.sizeForStack = $1.sizeForStack;}
			|	FormalDecl	COMMA	FormalsList {$$.sizeForStack = $3.sizeForStack + $1.sizeForStack;}
			;
				
FormalDecl	:	Type	ID { funcArgs.push_back(createFunctionSymbol($2.name, $1.type, -1)); $$.sizeForStack = 1;}
			|	Type	ID	LBRACK	NUM	RBRACK { validateArraySize($4.num_value, $2.name); funcArgs.push_back(createFunctionSymbol($2.name, $1.type, $4.num_value)); $$.sizeForStack = 1;}
			|	Type	ID	LBRACK	NUM		B	RBRACK { checkByteSize($4.num_value, $4.name); validateArraySize($4.num_value, $2.name);  funcArgs.push_back(createFunctionSymbol($2.name, $1.type, $4.num_value)); $$.sizeForStack = 1;}
			;
				
Statements	:	Statement 
				{
					//////
					//
					//					CodeBuffer::instance().emit("finishing statement 1 is: " + $1.name
					//+", whileBreakList size is: " + intToString($1.whileBreakList.size()));
					//$$.name = $1.name;
					//////
					
					
					CodeBuffer::instance().bpatch($1.nextList, CodeBuffer::instance().genLabel()); 
					//$$.nextList = $1.nextList;
					$$.whileBreakList = $1.whileBreakList;
				}
			|	Statements	 Statement 
				{
					CodeBuffer::instance().bpatch($2.nextList, CodeBuffer::instance().genLabel());
					//$$.nextList = CodeBuffer::instance().merge($1.nextList, $2.nextList);
					$$.whileBreakList = CodeBuffer::instance().merge($1.whileBreakList, $2.whileBreakList);
				}
			;

Statement	:	LBRACE	 ScopeStart	Statements RBRACE ScopeEnd
				{
					
					$$.whileBreakList = $3.whileBreakList; 
					//////
					//CodeBuffer::instance().emit("in {statements}\n");
					//
					//					CodeBuffer::instance().emit("finishing statement 2 is: " + $3.name
					//+", whileBreakList size is: " + intToString($3.whileBreakList.size()));
					//$$.name = $3.name;
					//////
				}  
			|	Type	ID	SC 	{  validateNotAlreadyDefined($2.name); createAndPushSymbol($2.name, $1.type,-1);}/*TODO-check!.!*/
			|	Type	ID	ASSIGN	Exp	SC	
				{ 
					validateNotAlreadyDefined($2.name); validateAssignment($1.type, $4.type); 
					createAndPushSymbol($2.name, $1.type,-1); 
					
					if ($1.type == Type_BOOL) 
					{
						handleBoolean($4);
						//$$.nextList = $4.nextList;
					}
					//cout<<"fafa\n";
					storeValInStack($2.name, $4.resultReg);
				}
			|	Type	ID	LBRACK	NUM	RBRACK	SC 
				{  
					validateNotAlreadyDefined($2.name); 
					isIntOrByte($4.type); 
					validateArraySize($4.num_value, $2.name); 
					createAndPushSymbol($2.name, $1.type,$4.num_value); 
				}
			|	Type	ID	LBRACK	NUM	B 	RBRACK SC 
				{	
					validateNotAlreadyDefined($2.name); 
					isIntOrByte($4.type); 
					checkByteSize($4.num_value, $4.name); 
					validateArraySize($4.num_value, $2.name); 
					createAndPushSymbol($2.name,$1.type,$4.num_value); 
					/*we take: A[5 b] same as: A[5]*/ 
				}
			|	ID	ASSIGN	Exp	SC 
				{  
					validateDefined($1.name,true);  
					validateAssignmentDynamic($1.name, $3.name, $3.type,$3.is_array);
					if ($3.type == Type_BOOL) 
					{
						handleBoolean($3);
					}
					//cout<<"kaka\n";
					storeValInStack($1.name, $3.resultReg);
				}
			|	ID	LBRACK  Exp RBRACK ASSIGN Exp SC  
				{ 
					validateDefined($1.name,true); 
					isIntOrByte($3.type); 
					validateAssignment(validateAndGetTypeByName($1.name, true), $6.type); 
					checkRHSNotArray($6.is_array); 
					validateIsArray($1.name);					 
					
					//checking if [exp] is not out of range
					checkIndexOutOfRange($1,$3); 
					

					if ($6.type == Type_BOOL) 
					{
						handleBoolean($6);
					}
					
					//cout<<"TATA\n";
					storeValArrayInStack($1.name, $3.resultReg, $6.resultReg);
					
					
				}
			|	Call SC
			|	RETURN  SC { checkFuncValidReturn(Type_VOID,-1, false); int tmp = CodeBuffer::instance().emit("b ");RABpatchMagic.push_back(tmp);}
			|	RETURN  Exp SC {checkFuncValidReturn($2.type,getExpSizeFromTable($2.name),$2.is_array);
 
				if ($2.type == Type_BOOL) 
				{
					handleBoolean($2);
					
					//CodeBuffer::instance().emit("its a boolean");
				}
				
				//if ($2.resultReg == -1) {
				//	CodeBuffer::instance().emit( "found -1 : " + $2.name );
				//}
				
				CodeBuffer::instance().emit("move\t$v0 ,$" + intToString($2.resultReg) + "\n" ); 
				//those 2 tests are on level 5.
				markRegisterUnused($2.resultReg);

				int tmp = CodeBuffer::instance().emit("b ");
				RABpatchMagic.push_back(tmp);



				}
			| 	IF LPAREN  Exp_boolean RPAREN ScopeStart M  Statement ScopeEnd 
				{
					CodeBuffer::instance().bpatch($3.trueList,$6.instr); 
					//CodeBuffer::instance().bpatch($3.falseList,CodeBuffer::instance().genLabel()); 
					$$.nextList=CodeBuffer::instance().merge($3.falseList,$7.nextList);
					$$.whileBreakList = $7.whileBreakList;
				} 
			|   IF LPAREN  Exp_boolean RPAREN ScopeStart M  Statement ScopeEnd ELSE ScopeStart N M Statement ScopeEnd
				{
					bpIF2Statement($$,$3,$6,$12,$7,$11,$13);
					
					//////


					//CodeBuffer::instance().emit("finishing if (statement) whileBreakList size is: " + intToString($7.whileBreakList.size()));					
					//CodeBuffer::instance().emit("finishing else statement whileBreakList size is: " + intToString($13.whileBreakList.size()));
					//////
					$$.whileBreakList = CodeBuffer::instance().merge($7.whileBreakList, $13.whileBreakList);
				} 
				
			|	WHILE startWhile LPAREN M Exp  RPAREN  
				{
					isBoolean($5.type);
				} 
				ScopeStart M Statement ScopeEnd endWhile
				{
					CodeBuffer::instance().bpatch($10.nextList,$4.instr); 
					CodeBuffer::instance().bpatch($5.trueList,$9.instr);
					
					//////


					//CodeBuffer::instance().emit("finishing while statement is: " + $10.name
					//+", whileBreakList size is: " + intToString($10.whileBreakList.size()));
					////////
					$$.nextList = CodeBuffer::instance().merge($10.whileBreakList, $5.falseList);
					
					CodeBuffer::instance().emit("b " + $4.instr);
					
				} 
			|	BREAK SC 
				{
					if ((m_iWhileCounter) <= 0) {
						errorUnexpectedBreak(yylineno); exit(0);
					}
					$$.whileBreakList = CodeBuffer::makelist(CodeBuffer::instance().emit("j "));
					
					//////
					//CodeBuffer::instance().emit("in break---");
					//$$.name = "break!!";
					/////////
					
				}
			;
			
startWhile	: {m_iWhileCounter++;};
endWhile	: {m_iWhileCounter--;};

		
Call 		:	ID LPAREN ExpList RPAREN 
				{
					$$.type = validateAndGetTypeByName($1.name, false); 
					validateCallFunction($1.name, funcCallTypes); 
					funcCallTypes.clear();
					beforeFuncCall();
					
					if ($3.usedRegsByExplist.size() > 0)
					{
						storeValListInStack($3.usedRegsByExplist);
					}
					
					CodeBuffer::instance().emit("jal\t"+ $1.name + "\n");
				}

			|  	ID LPAREN RPAREN 
				{
					$$.type = validateAndGetTypeByName($1.name, false); 
					validateCallFunction($1.name, funcCallTypes); 
					funcCallTypes.clear();	
					beforeFuncCall();CodeBuffer::instance().emit("jal\t"+ $1.name + "\n");
				}
			;
				
ExpList 	:	Exp 
				{
					EXP_ATTRIBUTE symbol; 
					symbol.type=$1.type; 
					symbol.name=$1.name; 
					funcCallTypes.push_back(symbol);
					
					int sizeForStack = 1;
					if ($1.is_array)
					{
						//////HERE
						sizeForStack = 1;
					}
					
					$$.sizeForStack = sizeForStack;
					if ($1.type == Type_BOOL) 
					{
						handleBoolean($1);
						//$$.nextList = $1.nextList;
					}
					
					$$.usedRegsByExplist.push_back($1.resultReg); 

				}
			|	Exp COMMA ExpList 
				{
					if ($1.type == Type_BOOL) 
					{
						handleBoolean($1);
						//$$.nextList = $1.nextList;
					}
					EXP_ATTRIBUTE symbol; 
					symbol.type=$1.type; 
					symbol.name=$1.name; 
					funcCallTypes.push_back(symbol);
					
					int sizeForStack = 1;
					if ($1.is_array)
					{
						//////HERE
						sizeForStack = 1;
					}
					
					$$.sizeForStack = $3.sizeForStack+sizeForStack;
					
					$$.usedRegsByExplist = $3.usedRegsByExplist;
					$$.usedRegsByExplist.push_back($1.resultReg); 
				}
			;
			
Type		:	INT		{ $$.type = Type_INT;}
			|	BYTE	{ $$.type = Type_BYTE;}
			|	BOOL	{ $$.type = Type_BOOL;};

			
Exp 		:	LPAREN Exp RPAREN {$$.type=$2.type; $$.trueList = $2.trueList; $$.falseList = $2.falseList;$$.resultReg=$2.resultReg;}
			|	ID LBRACK Exp RBRACK {
				$$.type=validateAndGetTypeByName($1.name, true); 
				$$.name = $1.name; 
				isIntOrByte($3.type); 
				validateIsArray($1.name);

				checkIndexOutOfRange($1,$3);
				

				T_Symbol symb=getSymbol($1.name);

				int posOfVar=symb.offset;	
				int offsetFromFP = posOfVar;  
				int iDestRegister = getFirstAvailableRegister();
				markRegisterUsed(iDestRegister);

				if (symb.type == Type_BOOL)
				{
					int iRegister = getFirstAvailableRegister();
					markRegisterUsed(iRegister);
					CodeBuffer::instance().emit("li\t$" + intToString(iRegister) +", 1\n");
					createRelop($$, iRegister, iDestRegister,"==");		
				}
				int tmpRegister = getFirstAvailableRegister();
				markRegisterUsed(tmpRegister);
				CodeBuffer::instance().emit("addi\t$" + intToString(tmpRegister) + ", $" + intToString($3.resultReg)+", "+intToString(offsetFromFP) +"\n");
				CodeBuffer::instance().emit("sub\t$" + intToString(tmpRegister) + ", $0 " + ", $" + intToString(tmpRegister) +"\n");
				//tmpRegister holds -offset, now we need to *4
				int tmpRegister2=putNumInRegister(VAR_SIZE);
				generateBinop3("*",tmpRegister,tmpRegister2,Type_INT);
				//tmpregister2 is freed.
				

				CodeBuffer::instance().emit("add\t$" + intToString(tmpRegister) + ", $" +intToString(tmpRegister)+", $fp\n");
				CodeBuffer::instance().emit("lw\t$" + intToString(iDestRegister) + ", ($" +intToString(tmpRegister)+")\n");
				$$.resultReg=iDestRegister;
				markRegisterUnused(tmpRegister);
			}

			|	ID				
				{ 
					$$.type = validateAndGetTypeByName($1.name, true);
					$$.name = $1.name; 
					$$.is_array = getIsArray($1.name); 
						
					////////
					//CodeBuffer::instance().emit("loading from stack: " + variable + "\n");
					//CodeBuffer::instance().emit("loading from offset is: " + intToString(symb.offset) + "\n");
					///////////
					T_Symbol symb=getSymbol($1.name);
					if ($$.is_array) {
						//for (int i = 0; i < symb.Type_ARRAY_SIZE; i ++)
						//{
						//	loadValFromStack(symb.offset, $$, symb.type);
						//}
					}
					$$.resultReg=loadValFromStack(symb.offset, $$, symb.type);

				}
			|	Call			{ 
			$$.type = $1.type;

					$$.resultReg = getFirstAvailableRegister();
					markRegisterUsed($$.resultReg);
					CodeBuffer::instance().emit("move\t$"+ intToString($$.resultReg) +" , $v0\n");
					if($1.type == Type_BOOL)
						{	
							int tmpReg = getFirstAvailableRegister();
							markRegisterUsed(tmpReg);
							CodeBuffer::instance().emit("li\t$" + intToString(tmpReg) +", 1");							
							createRelop($$,$$.resultReg,tmpReg,"==");
							//resultreg and tmpreg are freed
							
							$$.resultReg = -1;
						}
				


				}
			|	NUM				{ $$.type = Type_INT; $$.num_value = $1.num_value; $$.resultReg = putNumInRegister($1.num_value);}
			| 	NUM B			{ checkByteSize($1.num_value,$1.name); $$.type = Type_BYTE; $$.num_value = $1.num_value; $$.resultReg = putNumInRegister($1.num_value);}
			| 	STRING			{ $$.type = Type_STRING;$$.name = $1.name;

				ostringstream ss;
				ss << "mylbl_"<<labelCounter;
				$$.resultReg=getFirstAvailableRegister();
				markRegisterUsed($$.resultReg);
				CodeBuffer::instance().emitData(ss.str() + ": .asciiz " +$1.name);				
				CodeBuffer::instance().emit("la\t$" + intToString($$.resultReg) +", " + ss.str() + "\n");
				labelCounter++;
				}
			|	TRUE			{ $$.type = Type_BOOL; $$.trueList = CodeBuffer::makelist(CodeBuffer::instance().emit("b "));}
			|	FALSE			{ $$.type = Type_BOOL; $$.falseList = CodeBuffer::makelist(CodeBuffer::instance().emit("b "));}
			|	Exp BINOP_1 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = getTypeBinop($1.type, $3.type); $$.resultReg = generateBinopRes1($2.name, $1, $3, $$.type);}
			|	Exp BINOP_2 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = getTypeBinop($1.type, $3.type); $$.resultReg = generateBinopRes2($2.name, $1, $3, $$.type);}
			|	Exp AND M Exp	{ isBoolean($1.type); isBoolean($4.type); $$.type = Type_BOOL;performAnd($$,$1,$4, $3);}
			|	Exp OR M Exp	{ isBoolean($1.type); isBoolean($4.type); $$.type = Type_BOOL;performOr($$,$1,$4, $3);}
			| 	Exp RELOP_1 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = Type_BOOL; createRelop($$, $1.resultReg, $3.resultReg, $2.name);}
			| 	Exp RELOP_2 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = Type_BOOL; createRelop($$, $1.resultReg, $3.resultReg, $2.name);}
			|	NOT Exp			{ isBoolean($2.type);  $$.type = Type_BOOL; $$.trueList = $2.falseList; $$.falseList = $2.trueList;}
			;

Exp_boolean	:   Exp {isBoolean($1.type); $$.trueList = $1.trueList; $$.falseList = $1.falseList; $$.nextList = $1.nextList;}
			;

ScopeStart	:	{start_Scope(); }
			;
			
ProgramScopeStart	:	{ initRegisterPool();/*initCurrentRegPool();*/ program_scope_start(); }
			;
			
ScopeStartFunction	:	{start_scope_function();}
			;
		
ScopeEnd	:	{end_Scope();}
			;
ProgramScopeEnd	:	{end_Scope(); CodeBuffer::instance().printDataBuffer();  CodeBuffer::instance().printCodeBuffer();}
			;

M			:	{generateMMarker($$);}	
			;
N			:	{generateNMarker($$);}	
			;

%%

/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5*/

void handleBoolean(EXP_ATTRIBUTE& exp)
{
	markRegisterUnused(exp.resultReg);
	//cout<<"exp.resultreg is "<<exp.resultReg<< "id is "<< exp.name;
	int newReg = getFirstAvailableRegister();
	markRegisterUsed(newReg);
	string TRUELBL = CodeBuffer::instance().genLabel();
	CodeBuffer::instance().emit("li\t$" + intToString(newReg) + ", 1\n");
	int jmp = CodeBuffer::instance().emit("b ");
	string FALSELBL = CodeBuffer::instance().genLabel();
	CodeBuffer::instance().emit("li\t$" + intToString(newReg) + ", 0\n");
	string tar = CodeBuffer::instance().genLabel();
	CodeBuffer::instance().bpatch(CodeBuffer::instance().makelist(jmp), tar);
	CodeBuffer::instance().bpatch(exp.falseList, FALSELBL);
	CodeBuffer::instance().bpatch(exp.trueList, TRUELBL);
	
	exp.resultReg = newReg;
}

void createRelop(EXP_ATTRIBUTE& leftExp, int reg1, int reg2, string op)
{
	string sIfStatement = performRelop(reg1, reg2, op);
	int iNextInstruction1 = CodeBuffer::instance().emit(sIfStatement);
	leftExp.trueList.push_back(iNextInstruction1);
	
	int iNextInstruction2 = CodeBuffer::instance().emit("b ");
	leftExp.falseList.push_back(iNextInstruction2);
	
	markRegisterUnused(reg1);
	markRegisterUnused(reg2);
}

string performRelop(int reg1, int reg2, string op)
{
	string res = "";
	if (op.compare("==") == 0)
	{
		// beq	$t0,$t1,target	#  branch to target if  $t0 = $t1
		res += "beq\t";
	}
	else if (op.compare("!=") == 0)
	{
		// bne	$t0,$t1,target	#  branch to target if  $t0 <> $t1
		res += "bne\t";
	}
	else if (op.compare("<") == 0)
	{
		// blt	$t0,$t1,target	#  branch to target if  $t0 < $t1
		res += "blt\t";
	}
	else if (op.compare("<=") == 0)
	{
		// ble	$t0,$t1,target	#  branch to target if  $t0 <= $t1
		res += "ble\t";
	}
	else if (op.compare(">") == 0)
	{
		// bgt	$t0,$t1,target	#  branch to target if  $t0 > $t1
		res += "bgt\t";
	}
	else if (op.compare(">=") == 0)
	{
		// bge	$t0,$t1,target	#  branch to target if  $t0 >= $t1
		res += "bge\t";
	}
	
	res += "$" + intToString(reg1) + ", $" + intToString(reg2) + ", "; /// there's a blank here for the label inserted when backpatching
	return res;
}

void initRegisterPool()
{
	for(int i=0;i<REG_POOL_SIZE;i++)
		registerPool[i]=0;

}
void initCurrentRegPool()
{
	for(int i=0;i<REG_POOL_SIZE;i++)
		registerPool[i]=0;
}
void loadRegistersFromMainToCurrent()
{
	for(int i=0;i<REG_POOL_SIZE;i++)
		currentRegisterPool[i]=registerPool[i];
}
void loadRegistersFromCurrentToMain()
{
	for(int i=0;i<REG_POOL_SIZE;i++)
		registerPool[i]=currentRegisterPool[i];
}
int getFirstAvailableRegister()
{
	for(int i=8;i<REG_POOL_SIZE;i++)
	{
		if(registerPool[i]==0)
		{
			return i;
		}
	}
	return -1;
	
}

void markRegisterUnused(int iRegisterNumber)
{
	if(iRegisterNumber>=0 && iRegisterNumber<REG_POOL_SIZE)
		registerPool[iRegisterNumber] = 0;
}

void markRegisterUsed(int iRegisterNumber)
{
	registerPool[iRegisterNumber] = 1;
}
void performAnd(EXP_ATTRIBUTE& leftExp, EXP_ATTRIBUTE e1,EXP_ATTRIBUTE e2, EXP_ATTRIBUTE  M)
{
	CodeBuffer::instance().bpatch(e1.trueList,M.instr);
	leftExp.trueList = e2.trueList;
	leftExp.falseList = CodeBuffer::instance().merge(e1.falseList,e2.falseList);

}
void performOr(EXP_ATTRIBUTE& leftExp, EXP_ATTRIBUTE e1,EXP_ATTRIBUTE e2, EXP_ATTRIBUTE  M)
{
	CodeBuffer::instance().bpatch(e1.falseList, M.instr);
	leftExp.trueList = CodeBuffer::instance().merge(e1.trueList, e2.trueList);
	leftExp.falseList = e2.falseList;
}
int putNumInRegister(int num_value)
{
	int registerNum = getFirstAvailableRegister();	
	markRegisterUsed(registerNum);
	///li	$t1, 5	
	string toEmit = "li\t$" + intToString(registerNum) + ", " + intToString(num_value);
	
	CodeBuffer::instance().emit(toEmit);
	
	return registerNum;
}

int generateBinopRes2(string op, EXP_ATTRIBUTE b1, EXP_ATTRIBUTE b2, Type resType)
{
	int iB1Register = b1.resultReg;
	int iB2Register = b2.resultReg;
	
	
	
	if 		(op.compare("-") == 0) 
	{
		if (resType == Type_INT)
		{
			CodeBuffer::instance().emit(performSubInt_ResInResRegister(iB1Register, iB2Register, iB1Register));
		}
		else
		{
			CodeBuffer::instance().emit(performSubByte_ResInResRegister(iB1Register, iB2Register, iB1Register));			
		}
	}
	else if (op.compare("+") == 0) 
	{
		if (resType == Type_INT)
		{
			CodeBuffer::instance().emit(performAddInt_ResInResRegister(iB1Register, iB2Register, iB1Register));
		}
		else
		{
			CodeBuffer::instance().emit(performAddByte_ResInResRegister(iB1Register, iB2Register, iB1Register));
		}
	}

	if(resType==Type_BYTE)
	{
		//handling bool overflow- truncating it with a mask, so result is in range 0-255
		CodeBuffer::instance().emit("and\t$"+intToString(iB1Register) + ", $" +intToString(iB1Register)+ " , 0x000000ff\n");
	}	
	
	markRegisterUnused(iB2Register);
	//// could be optimized to use B1 again as result register
	
	return iB1Register;
}

string performSubByte_ResInResRegister(int iB1Register, int iB2Register, int resRegister)
{
	//addu	$t1,$t6,$t7
	return "subu\t$" + intToString(resRegister) + ", $" + intToString(iB1Register) + ", $" + intToString(iB2Register) + "\n";

}

string performSubInt_ResInResRegister(int iB1Register, int iB2Register, int resRegister)
{
	//addu	$t1,$t6,$t7
	return "sub\t$" + intToString(resRegister) + ", $" + intToString(iB1Register) + ", $" + intToString(iB2Register) + "\n";
}

string performAddInt_ResInResRegister(int iB1Register, int iB2Register, int resRegister)
{
	//addu	$t1,$t6,$t7
	return "add\t$" + intToString(resRegister) + ", $" + intToString(iB1Register) + ", $" + intToString(iB2Register) + "\n";
}

string performAddByte_ResInResRegister(int iB1Register, int iB2Register, int resRegister)
{
	//addu	$t1,$t6,$t7
	return "addu\t$" + intToString(resRegister) + ", $" + intToString(iB1Register) + ", $" + intToString(iB2Register) + "\n";
}


int generateBinopRes1(string op, EXP_ATTRIBUTE b1, EXP_ATTRIBUTE b2,Type resType)
{
	int iB1Register = b1.resultReg;
	int iB2Register = b2.resultReg;

	if (op.compare("/") == 0)
	{
		CodeBuffer::instance().emit(performDiv_ResInB1(iB1Register, iB2Register));
	}
	else if (op.compare("*") == 0) {
		
		
		CodeBuffer::instance().emit(performMul_ResInB1(iB1Register, iB2Register));
		if(resType==Type_BYTE)
		{
			//handling bool overflow- truncating it with a mask, so result is in range 0-255
			CodeBuffer::instance().emit("and\t$"+intToString(iB1Register) + ", $" +intToString(iB1Register)+ " , 0x000000ff\n");
		
		}
		
			
	}

	
	markRegisterUnused(iB2Register);
	
	return iB1Register;
	//// result in iB1Register
}

int generateBinop3(string op, int iB1Register,int iB2Register, Type resType)
{
	if (op.compare("/") == 0)
	{
		CodeBuffer::instance().emit(performDiv_ResInB1(iB1Register, iB2Register));
	}
	else if (op.compare("*") == 0) {
		
		
		CodeBuffer::instance().emit(performMul_ResInB1(iB1Register, iB2Register));
		if(resType==Type_BYTE)
		{
			//handling bool overflow- truncating it with a mask, so result is in range 0-255
			CodeBuffer::instance().emit("and\t$"+intToString(iB1Register) + ", $" +intToString(iB1Register)+ " , 0x000000ff\n");
		
		}
		
			
	}

	
	markRegisterUnused(iB2Register);
	
	return iB1Register;
	//// result in iB1Register
}

void addDiv0Func()
{
	CodeBuffer::instance().emitData("throwDivException: .asciiz \"Error division by zero\\n\"");
	CodeBuffer::instance().emit("divisionERR:");	
	CodeBuffer::instance().emit("li $v0,4");
	CodeBuffer::instance().emit("la $a0,throwDivException");
	CodeBuffer::instance().emit("syscall");
	CodeBuffer::instance().emit("li $v0,10");
	CodeBuffer::instance().emit("syscall");
}
void addIndexOutOfRangeFunc()
{
	CodeBuffer::instance().emitData("throwIndexOutOfRange: .asciiz \"Error index out of bounds\\n\"");
	CodeBuffer::instance().emit("indexERR:");	
	CodeBuffer::instance().emit("li $v0,4");
	CodeBuffer::instance().emit("la $a0,throwIndexOutOfRange");
	CodeBuffer::instance().emit("syscall");
	CodeBuffer::instance().emit("li $v0,10");
	CodeBuffer::instance().emit("syscall");

}

void addPrintPrintiDiv0()
{
	addDiv0Func();
	addPrintFunc();
	addPrintiFunc();
}


void checkIndexOutOfRange(EXP_ATTRIBUTE array,EXP_ATTRIBUTE variable)
{
	T_Symbol arraySymb=getSymbol(array.name);	
	int arraySizeRegister=getFirstAvailableRegister();
	markRegisterUsed(arraySizeRegister);	
	//loading their values into the registers
	CodeBuffer::instance().emit("li\t$" + intToString(arraySizeRegister) + "," +  intToString(  arraySymb.Type_ARRAY_SIZE  - 1) + "\n"); 

	 //checking that size isn't greater than array size
	CodeBuffer::instance().emit("bgt\t$" + intToString(variable.resultReg) + " , $" + intToString(arraySizeRegister) + " , indexERR\n");
	//checking that size is at least zero
	CodeBuffer::instance().emit("blt\t$" + intToString(variable.resultReg) + " , $0" +   " , indexERR\n"); 

	markRegisterUnused(arraySizeRegister);
	
	
}

int getOffset(string name)
{
	T_Symbol symb=getSymbol(name);
	if(symb.type == __Type_INVALID )
	{
		errorUndef(yylineno, name);
		exit(0);
	}
	return symb.offset;
}
string performMul_ResInB1(int iB1Register, int iB2Register)
{
	
	string res = "mult\t$" + intToString(iB1Register) + ", $" + intToString(iB2Register) + "\n";
	res += "mflo\t$" + intToString(iB1Register);

	return res;
}

string performDiv_ResInB1(int iB1Register, int iB2Register)
{
	int tmpReg=getFirstAvailableRegister();



	//TODO: put in func
	markRegisterUsed(tmpReg);
	
	CodeBuffer::instance().emit("li\t$" + intToString(tmpReg) + " , 0\n");
	CodeBuffer::instance().emit("beq\t$"+intToString(tmpReg) + ", $" + intToString(iB2Register) + ", divisionERR\n");
	//cout << "#tmpReg: " << tmpReg << ", iB1Register: " << iB1Register << ", iB2Register: " << iB2Register << endl;
	markRegisterUnused(tmpReg);
	//TODO: put in func



	string res = "div\t$" + intToString(iB1Register) + ", $" + intToString(iB2Register) + "\n";
	res += "mflo\t$" + intToString(iB1Register);
	return res;
}

string intToString(int theInt)
{
	ostringstream stream;
	stream << theInt;
	return stream.str();
}

void generateMMarker(EXP_ATTRIBUTE& exp)
{
	exp.instr=CodeBuffer::instance().genLabel();
}

void generateNMarker(EXP_ATTRIBUTE& exp)
{
	exp.nextList=CodeBuffer::makelist(CodeBuffer::instance().emit("b "));
}

void saveAllRegisters()
{
	CodeBuffer::instance().emit("addi $sp , $sp,-72\n");

	for(int i=0;i<18;i++)
	{
		ostringstream ss;
		ss<< i*VAR_SIZE;
		CodeBuffer::instance().emit("sw\t$"  + intToString(i+8) +", " + ss.str()+  "($sp)\n");
	}
	//loadRegistersFromMainToCurrent();
	//initRegisterPool();//they are saved, so now they are all free to use!
	
}

void loadAllRegisters()
{
	for(int i=0;i<18;i++)
	{
		ostringstream ss;
		ss<< i*VAR_SIZE;
		CodeBuffer::instance().emit("lw\t$" + intToString(i+8) + "," +ss.str()+  "($sp)\n");
	}
	CodeBuffer::instance().emit("addi $sp , $sp,72\n");
	//loadRegistersFromCurrentToMain();
	//initCurrentRegPool();

	
}

void storeValInStack(string variable, int iRegisterNumber)
{
	//cout<<"STOREVALINSTACK entered\n";
	int posOfVar=getOffset(variable);	//TODO- make sure its correct
	int offsetFromFP = -posOfVar*VAR_SIZE;
	ostringstream ss;
	ss << offsetFromFP;
	CodeBuffer::instance().emit("sw\t$" + intToString(iRegisterNumber) + ", " +ss.str()+"($fp)\n");
	markRegisterUnused(iRegisterNumber);
}
void storeValArrayInStack(string arrayID, int indexRegister, int toStoreRegister)
{
	T_Symbol symb=getSymbol(arrayID);
	
	int offsetFromFP=symb.offset;	
 
	int tmpRegister = getFirstAvailableRegister();
	markRegisterUsed(tmpRegister);
	CodeBuffer::instance().emit("addi\t$" + intToString(tmpRegister) + ", $" +intToString(indexRegister)+", "+intToString(offsetFromFP) +"\n");
	CodeBuffer::instance().emit("sub\t$" + intToString(tmpRegister) + ", $0 " + ", $" + intToString(tmpRegister) +"\n");
	//tmpRegister holds -offset, now we need to *4
	int tmpRegister2=putNumInRegister(VAR_SIZE);
	generateBinop3("*",tmpRegister,tmpRegister2,Type_INT);
	//tmpregister2 is freed.
	
	///tmpRegister has the offset now
	
	CodeBuffer::instance().emit("add\t$" + intToString(tmpRegister) + ", $" +intToString(tmpRegister)+", $fp\n");
	
	CodeBuffer::instance().emit("sw\t$" + intToString(toStoreRegister) + ", ($" + intToString(tmpRegister) + ")\n");
	markRegisterUnused(tmpRegister);
	
	markRegisterUnused(toStoreRegister);
	markRegisterUnused(indexRegister);
}

int loadValFromStack(int posOfVar, EXP_ATTRIBUTE& leftExp, Type type)
{
	/// TODO: deal with array

	int offsetFromFP = -posOfVar*VAR_SIZE;
	int iDestRegister = getFirstAvailableRegister();
	markRegisterUsed(iDestRegister);

	if (type == Type_BOOL)
	{
		int iRegister = getFirstAvailableRegister();
		markRegisterUsed(iRegister);
		CodeBuffer::instance().emit("li\t$" + intToString(iRegister) +", 1\n");
		createRelop(leftExp, iRegister, iDestRegister,"==");
		
	}
	
	ostringstream ss;
	ss << offsetFromFP;
	CodeBuffer::instance().emit("lw\t$" + intToString(iDestRegister) + ", " +ss.str()+"($fp)\n");
	return iDestRegister;
}

void addPrintHelper()
{
	CodeBuffer::instance().emit("lw\t$a0,0($sp)\n");
	CodeBuffer::instance().emit("li\t$v0,4\n");
	CodeBuffer::instance().emit("syscall\n");
	CodeBuffer::instance().emit("add\t$sp, $fp, 8\n");
	CodeBuffer::instance().emit("lw\t$ra, 0($sp)\n");
	CodeBuffer::instance().emit("lw\t$fp, 4($sp)\n");
	CodeBuffer::instance().emit("add\t$sp, $sp, 8\n");
}
void addPrintiHelper()
{
	CodeBuffer::instance().emit("lw\t$a0,0($sp)\n");
	CodeBuffer::instance().emit("li\t$v0,1\n");
	CodeBuffer::instance().emit("syscall\n");
	CodeBuffer::instance().emit("add\t$sp, $fp, 8\n");
	CodeBuffer::instance().emit("lw\t$ra, 0($sp)\n");
	CodeBuffer::instance().emit("lw\t$fp, 4($sp)\n");
	CodeBuffer::instance().emit("add\t$sp, $sp, 8\n");
}

void initializeStackFP()
{
	CodeBuffer::instance().emit("addi $fp, $sp, -4\n");
}
void storeValListInStack( vector<int> values)
{
	int offset = values.size()*VAR_SIZE; 
	ostringstream ss;
	ostringstream ss2;
	ss << offset;
	CodeBuffer::instance().emit("add $sp , $sp , -"+ ss.str() +"\n");

	for(int i =0;i<values.size();i++)
	{		
		ss2 << VAR_SIZE*i;
		CodeBuffer::instance().emit("sw\t$" +intToString(values[values.size() - i -1]) +", " + ss2.str() +"($sp)\n");
		markRegisterUnused(values[values.size() -i -1]);
	}

}
void storeFuncRetAddrInStack(int numOfArgs)
{	
	int offset = (numOfArgs)*VAR_SIZE;
	ostringstream sstr;
	sstr << offset;
	CodeBuffer::instance().emit("sw\t$ra , "+ sstr.str()+"($sp)");
	//TODO: find out numOfArgs
}
void addPrintFunc(){
	//TODO: use this and addprinti when starting the program
	CodeBuffer::instance().emit("print:");
	initializeStackFP();
	storeFuncRetAddrInStack(1);
	addPrintHelper();
	loadAllRegisters();
	CodeBuffer::instance().emit("jr\t$ra\n");
}
void addPrintiFunc()
{	
	CodeBuffer::instance().emit("printi:");
	initializeStackFP();
	storeFuncRetAddrInStack(1);
	addPrintiHelper();
	loadAllRegisters();
	CodeBuffer::instance().emit("jr\t$ra\n");
}
void beforeFuncCall()
{
	//save mr register:
	saveAllRegisters();

	//move sp down to add a slot for the return address and FP
	CodeBuffer::instance().emit("addi\t$sp, $sp, -8\n");
	//put the return address on the stack in that spot we just allocated
	CodeBuffer::instance().emit("sw\t$fp, 4($sp)\n");
	//todo- check if its working


	return;
}
void popStackAfterFunction (int size)
{	
	ostringstream ss;
	ss << VAR_SIZE*(size+1);
	CodeBuffer::instance().emit("addi\t$sp, $fp, " + ss.str()+"\n");
	CodeBuffer::instance().emit("lw\t$ra, 0($sp)\n");
	CodeBuffer::instance().emit("lw\t$fp, 4($sp)\n");
	CodeBuffer::instance().emit("addi\t$sp, $sp, 8\n");
	loadAllRegisters();
}
void bpIF2Statement(EXP_ATTRIBUTE& S,EXP_ATTRIBUTE B, EXP_ATTRIBUTE M1, EXP_ATTRIBUTE M2, EXP_ATTRIBUTE S1, EXP_ATTRIBUTE N, EXP_ATTRIBUTE S2)
{
	CodeBuffer::instance().bpatch(B.trueList,M1.instr);
	CodeBuffer::instance().bpatch(B.falseList,M2.instr);

	CodeBuffer::instance().bpatch(N.nextList, CodeBuffer::instance().genLabel());
	
	//not sure if above or this is the best solution
	//vector<int> temp= CodeBuffer::instance().merge(S1.nextList,N.nextList);
	//S.nextList=CodeBuffer::instance().merge(temp,S2.nextList);	
}
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5
/*******************************HW5*/

void validateIsArray(string name)
{
	if (!getIsArray(name))
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

void checkRHSNotArray(bool is_array)
{
	if (is_array)
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

bool getIsArray(string name)
{
	T_Symbol symbol=getSymbol(name);
	if(symbol.type != __Type_INVALID) // should always be defined but still
	{
		return symbol.Type_ARRAY_SIZE != -1;
	}
}

void validateFunctionArg(string varName)
{
	T_Symbol symbol=getSymbol(varName);
	if(symbol.type != __Type_INVALID)
	{
		if(symbol.isFunction)
		{
			errorDef(yylineno, varName);
			exit(0);
		}
	}
}

void validateCallFunction(string funcName, vector<EXP_ATTRIBUTE> callArgs)
{
	//cout << "validating " << funcName << endl;
	T_Symbol symbFunc=getSymbol(funcName);
	if(symbFunc.type == __Type_INVALID || !symbFunc.isFunction)
	{
		errorUndefFunc(yylineno, funcName);
		exit(0);
	}
	if (symbFunc.lstArgs.size() != callArgs.size())
	{
		//cout << "args list size is different, got " << callArgs.size() << endl;
		vector<string> lstStringArgs = generateStringTypes(symbFunc.lstArgs);
		errorPrototypeMismatch(yylineno, funcName, lstStringArgs);
		exit(0);
	}
	int i = 0;
	for (list<T_Symbol>::reverse_iterator it=symbFunc.lstArgs.rbegin(); it!=symbFunc.lstArgs.rend(); ++it)
	{
		T_Symbol currSymbol = *it;
		//cout << "currSymbol name: " << currSymbol.name << ", type is: " << currSymbol.type << endl;
		//cout << "args[i] is: " << callArgs[i].name << endl;
		//cout << "currSymbol.type " << (int)currSymbol.type << " callArgs[i].type" << (int)callArgs[i].type << endl;
		if (currSymbol.type != callArgs[i].type)
		{
			if (!(currSymbol.type == Type_INT && callArgs[i].type == Type_BYTE))
			{
				vector<string> lstStringArgs = generateStringTypes(symbFunc.lstArgs);
				errorPrototypeMismatch(yylineno, funcName, lstStringArgs);
				exit(0);
			}	
		}
		else 
		{
			if (currSymbol.Type_ARRAY_SIZE != -1)
			{
				T_Symbol argSymb = getSymbol(callArgs[i].name);
				if (argSymb.type != __Type_INVALID)
				{
					if (argSymb.Type_ARRAY_SIZE != -1)
					{
						if (argSymb.Type_ARRAY_SIZE != currSymbol.Type_ARRAY_SIZE)
						{
							vector<string> lstStringArgs = generateStringTypes(symbFunc.lstArgs);
							errorPrototypeMismatch(yylineno, funcName, lstStringArgs);
							exit(0);
						}
					}
					else
					{
						vector<string> lstStringArgs = generateStringTypes(symbFunc.lstArgs);
						errorPrototypeMismatch(yylineno, funcName, lstStringArgs);
						exit(0);
					}
				}
				else
				{
					vector<string> lstStringArgs = generateStringTypes(symbFunc.lstArgs);
					errorPrototypeMismatch(yylineno, funcName, lstStringArgs);
					exit(0);
				}
			}
		}
		i++;
	}
	
}

void checkHasMain()
{
	string sMainFuncName = "main";
	T_Symbol mainFunc=getSymbol(sMainFuncName);
	if(mainFunc.type != __Type_INVALID)
	{
		if(mainFunc.isFunction && mainFunc.type == Type_VOID)
		{
			if (mainFunc.lstArgs.empty())
			{
				return;
			}
		}
	}
	errorMainMissing();	
	exit(0);
}

void program_scope_start()
{
	start_Scope();
	
	T_Symbol stringSymbol;
	stringSymbol.type = Type_STRING;
	list<T_Symbol> lstArgs2;
	lstArgs2.push_back(stringSymbol);
	addFunctionToSymbolTable("print", Type_VOID, lstArgs2);
	
	T_Symbol integerSymbol;
	integerSymbol.type = Type_INT;
	list<T_Symbol> lstArgs1;
	lstArgs1.push_back(integerSymbol);
	addFunctionToSymbolTable("printi", Type_VOID, lstArgs1);

	T_Symbol voidSymbol;
	voidSymbol.type=Type_VOID;
	list<T_Symbol> lstArgs3;
	//lstArgs3.push_back(voidSymbol);
	addFunctionToSymbolTable("throwDivException", Type_VOID,lstArgs3);

}

void addFunctionToSymbolTable(string name, Type returnType, list<T_Symbol> args)
{
	T_Symbol funcSymbol;
	funcSymbol.isFunction = true;
	funcSymbol.name = name;
	funcSymbol.type = returnType;

	for (list<T_Symbol>::iterator it=args.begin(); it!=args.end(); ++it) 
	{
		T_Symbol symbol = *it;
		funcSymbol.lstArgs.push_back(symbol);
	}

	m_stScopeStack.front().addSymbol(funcSymbol);
}

void validateArraySize(int numValue, string name)
{
	if (numValue <= 0 || numValue >= 256)
	{
		errorInvalidArraySize(yylineno, name);
		exit(0);
	}
}



Type validateAndGetTypeByName(string name, bool isVariable)
{
	for (list<SymbolTable>::iterator it_st=m_stScopeStack.begin(); it_st!=m_stScopeStack.end(); ++it_st)
	{
		SymbolTable& currentTable = *it_st;
		if (currentTable.lstSymbols.size() > 0) {
			for (list<T_Symbol>::iterator it=currentTable.lstSymbols.begin(); it!=currentTable.lstSymbols.end(); ++it)
			{
				T_Symbol curr = *it;
				if(name == curr.name)
				{
					return curr.type;
				}
			}
			
		}
	}
	
	if(isVariable==true)
	{
		errorUndef(yylineno, name);	
	}
	else
	{
		errorUndefFunc(yylineno, name);
	}	
	exit(0);
	return (Type) -1;
}

Type getTypeBinop(Type t1, Type t2)
{
	if (t1 == t2)
	{
		//cout << "binop type is: " << t1 << endl;
		return t1;
	}
	//cout << "binop type is: " << Type_INT << endl;
	return Type_INT;
}

void isBoolean(Type t)
{
	
	if (t != Type_BOOL)
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

void isIntOrByte(Type t)
{
	//cout << "t type: " << t << endl;
	if (t != Type_INT && t != Type_BYTE)
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

void validateAssignmentDynamic(string lhsName, string rhsName, Type rhsType, bool rhs_is_array)
{
	
	T_Symbol lhsSymbol=getSymbol(lhsName);
	if(lhsSymbol.type == __Type_INVALID)
	{
		//should never reach here because we called validateDefined on the lhs symbol before this func

		//you called the wrong error again! i fixed it.
		
		errorUndef(yylineno, lhsName);	
		exit(0);
	}

	T_Symbol rhsSymbol=getSymbol(rhsName);
	
	if (lhsSymbol.Type_ARRAY_SIZE != -1)
	{
		/// lhs is an array
		
		if(rhsSymbol.type == __Type_INVALID) 
		{
			///rhs is not even a variable
			
			errorMismatch(yylineno);
			exit(0);
			return;
		}

		if (rhsSymbol.Type_ARRAY_SIZE != lhsSymbol.Type_ARRAY_SIZE)
		{
			
			errorMismatch(yylineno);
			exit(0);
		}
		///both are arrays from same size!
		
		if (rhsSymbol.type != lhsSymbol.type)
		{
			
			errorMismatch(yylineno);
			exit(0);
		}
		
		if(!rhs_is_array)
		{		
			 errorMismatch(yylineno);
			 exit(0);
		}
		
		
		///both are arrays from same size and type! SUCCESS
	}
	else /// lhs is not an array
	{
		if(rhs_is_array) 
		{
			
			errorMismatch(yylineno);
			exit(0);
			return;
		}
		validateAssignment(lhsSymbol.type, rhsType);
	}
}

void validateAssignment(Type lhs, Type rhs)
{
	

	if (lhs != rhs)
	{
		if (lhs == Type_INT && rhs == Type_BYTE)
		{
			return;
		}		
		errorMismatch(yylineno);
		exit(0);
	}
}

void start_Scope()
{
	SymbolTable newTable;
	m_stScopeStack.push_front(newTable);
	
}
bool contains(list<T_Symbol> lstStrings, string sym)
{
	vector<string> vec;
	for (list<T_Symbol>::iterator it=lstStrings.begin(); it!=lstStrings.end(); ++it) 
	{
		T_Symbol currSym = *it;
		vec.push_back(currSym.name);
	}
	return find(vec.begin(), vec.end(), sym) != vec.end();
}

void createFunctionObj(string name, Type type)
{
	list<T_Symbol> lstArgsTmp;
	
	for (list<T_Symbol>::iterator it=funcArgs.begin(); it!=funcArgs.end(); ++it) 
	{
		T_Symbol symbol = *it;

		validateFunctionArg(symbol.name);
		if (symbol.name.compare(name) == 0)
		{
			///current function arg has same name as function
			errorDef(yylineno, symbol.name);	
			exit(0);
		}
		if(contains(lstArgsTmp,symbol.name))
		{
			//2 function args with same name
			errorDef(yylineno, symbol.name);	
			exit(0);
		}		
		lstArgsTmp.push_back(symbol);
	}
	
	addFunctionToSymbolTable(name, type, lstArgsTmp);
}


void checkFuncValidReturn(Type type,int size, bool return_value_is_array)
{
	if (return_value_is_array)
	{
		errorMismatch(yylineno);
		exit(0);
	}

	for (list<SymbolTable>::iterator it_st=m_stScopeStack.begin(); it_st!=m_stScopeStack.end(); ++it_st)
	{
		SymbolTable& currentTable = *it_st;
		if (currentTable.lstSymbols.size() > 0)
		 {
			for (list<T_Symbol>::reverse_iterator it=currentTable.lstSymbols.rbegin(); it!=currentTable.lstSymbols.rend(); ++it)
			{
				T_Symbol curr = *it;
				if(curr.isFunction)
				{
					if(curr.type!=type && !(type == Type_BYTE && curr.type == Type_INT))
					{
						//cout<<"fun type: "<<curr.type << " type: "<< type;
						errorMismatch(yylineno);
						exit(0);
					}
					//its ok-finish
					return;
				}
			}
			
		}
	}


	// errorMismatch(yylineno);
	// exit(0);




}
void start_scope_function()
{
	SymbolTable newTable;
	for (list<T_Symbol>::iterator it=funcArgs.begin(); it!=funcArgs.end(); ++it) 
	{
		T_Symbol symbol = *it;
		//cout << "adding symbol: " << symbol.name << endl;
		newTable.addSymbol(symbol);
	}
	m_stScopeStack.push_front(newTable);
}

void end_scope2()
{
	int variablesCounter=0;
	SymbolTable& top = m_stScopeStack.front();
	endScope();
	if (top.lstSymbols.size() > 0) {
		for (list<T_Symbol>::iterator it=top.lstSymbols.begin(); it!=top.lstSymbols.end(); ++it) {
			T_Symbol curr = *it;
			

			
			if (curr.isFunction)
			{
				vector<string> lstArgsAsStrings = generateStringTypes(curr.lstArgs);
				//cout << "function type is: " << TYPES_TO_STRING[curr.type] << endl;
				string sFunctionType = makeFunctionType(TYPES_TO_STRING[curr.type], lstArgsAsStrings);
				printID(curr.name, 0, sFunctionType);
			}
			else
			{
				

				if (curr.Type_ARRAY_SIZE != -1)
				{
					variablesCounter+=curr.Type_ARRAY_SIZE;//TODO:make sure its the correct size
					string sArrayType = makeArrayType(TYPES_TO_STRING[curr.type], curr.Type_ARRAY_SIZE);
					printID(curr.name, curr.offset, sArrayType);
					//cout <<"curr name: "<<curr.name<< "curr offset: " << m_iCurrentOffset << "calling -arraysize"<< endl;

					if(curr.offset>=0)
						m_iCurrentOffset-=curr.Type_ARRAY_SIZE;
				}
				else
				{
					printID(curr.name, curr.offset, TYPES_TO_STRING[curr.type]);
					variablesCounter++;
					//cout <<"curr name: "<<curr.name<< "curr offset: " << m_iCurrentOffset << "calling --" <<endl;
					if(curr.offset>=0)
						m_iCurrentOffset--;				
					
				}

				
			}
		}
	}
	ostringstream ss;
	ss << VAR_SIZE* variablesCounter;

	m_stScopeStack.pop_front();
}
void end_Scope()
{
	int variablesCounter=0;
	SymbolTable& top = m_stScopeStack.front();
	endScope();
	if (top.lstSymbols.size() > 0) {
		for (list<T_Symbol>::iterator it=top.lstSymbols.begin(); it!=top.lstSymbols.end(); ++it) {
			T_Symbol curr = *it;
			

			
			if (curr.isFunction)
			{
				vector<string> lstArgsAsStrings = generateStringTypes(curr.lstArgs);
				//cout << "function type is: " << TYPES_TO_STRING[curr.type] << endl;
				string sFunctionType = makeFunctionType(TYPES_TO_STRING[curr.type], lstArgsAsStrings);
				printID(curr.name, 0, sFunctionType);
			}
			else
			{
				

				if (curr.Type_ARRAY_SIZE != -1)
				{
					variablesCounter+=curr.Type_ARRAY_SIZE;//TODO:make sure its the correct size
					string sArrayType = makeArrayType(TYPES_TO_STRING[curr.type], curr.Type_ARRAY_SIZE);
					printID(curr.name, curr.offset, sArrayType);
					//cout <<"curr name: "<<curr.name<< "curr offset: " << m_iCurrentOffset << "calling -arraysize"<< endl;

					if(curr.offset>=0)
						m_iCurrentOffset-=curr.Type_ARRAY_SIZE;
				}
				else
				{
					printID(curr.name, curr.offset, TYPES_TO_STRING[curr.type]);
					variablesCounter++;
					//cout <<"curr name: "<<curr.name<< "curr offset: " << m_iCurrentOffset << "calling --" <<endl;
					if(curr.offset>=0)
						m_iCurrentOffset--;				
					
				}

				
			}
		}
	}
	ostringstream ss;
	ss << VAR_SIZE* variablesCounter;
	//popping the scope stack:

	CodeBuffer::instance().emit("add\t$sp, $sp, " + ss.str()) + "\n";	
	m_stScopeStack.pop_front();
}

vector<string> generateStringTypes(list<T_Symbol> lstArgs)
{
	vector<string> lstArgsAsStrings;
	for (list<T_Symbol>::iterator it=lstArgs.begin(); it!=lstArgs.end(); ++it) 
	{
		T_Symbol symbol = *it;
		if (symbol.Type_ARRAY_SIZE != -1)
		{
			string sArrayType = makeArrayType(TYPES_TO_STRING[symbol.type], symbol.Type_ARRAY_SIZE);
			lstArgsAsStrings.push_back(sArrayType);
		}
		else
		{
			lstArgsAsStrings.push_back(TYPES_TO_STRING[symbol.type]);
		}
	}
	return lstArgsAsStrings;
}

void validateNotAlreadyDefined(string name)
{
	//cout << " name is: " << name << endl;
	T_Symbol result=getSymbol(name);
	if(result.type!=__Type_INVALID)
	{
		//if type is not invalid, symbol exists
		//, bad.
		errorDef(yylineno, name);	
		exit(0);
	}	
	
}


//will return error if its not defined. 
void validateDefined(string name, bool isVariable) 
{
	T_Symbol result=getSymbol(name);
	if(result.type==__Type_INVALID)
	{
		//doesnt exist, return error
		if(isVariable==true)
		{
			errorUndef(yylineno, name);	
		}
		else
		{
			errorUndefFunc(yylineno, name);
		}		
		exit(0);
	}
	if (result.isFunction == true &&  isVariable == true)
	{
		errorUndef(yylineno, name);	
		exit(0);
	}

}

T_Symbol createFunctionSymbol(string name, Type type, int size)
{
	//cout << "createFunctionSymbol called with name: " << name << endl;
	T_Symbol symbol;
	symbol.name = name;
	symbol.type = type;
	
	if(size>-1)//its an array!
	{
		symbol.Type_ARRAY_SIZE=size;		
		m_iFUNCTION_CurrentOffset-=(size-1);
	}

	symbol.offset = m_iFUNCTION_CurrentOffset--;
	
	return symbol;
}

int getExpSizeFromTable(string name)
{
	T_Symbol sym=getSymbol(name);
	return sym.Type_ARRAY_SIZE;
}



void createAndPushSymbol(string name, Type type, int size)
{
	//cout << "creating symbol with name: " << name << " in line: " << yylineno << endl;
	
	T_Symbol symbol;
	symbol.name = name;
	symbol.type = type;
	//cout <<"curr name: "<<symbol.name<< "curr offset: " << m_iCurrentOffset << "calling ++"<< endl;

	symbol.offset = m_iCurrentOffset++;
	symbol.Type_ARRAY_SIZE=-1;//redundant, taken care of in constructor

	//adding slot for it in the stack
	CodeBuffer::instance().emit("addi\t$sp, $sp, -4\n");	

	/////init///
	CodeBuffer::instance().emit("sw\t$0, ($sp)\n");
	//// end init ///

	if(size>-1)//its an array!
	{
		//cout <<"curr name: "<<symbol.name<< "curr offset: " << m_iCurrentOffset << "calling +arraysize"<< endl;
		symbol.Type_ARRAY_SIZE=size;		
		m_iCurrentOffset+=size-1;

		//adding additional slots for the array elements on the stack
		CodeBuffer::instance().emit("addi\t$sp, $sp, -" + intToString((size-1)*VAR_SIZE)+ "\n");
		for(int i =0;i<size;i++)
		{
			ostringstream ss;
			ss << VAR_SIZE*i;
			CodeBuffer::instance().emit("sw\t$0, " + ss.str() +"($sp)\n");
		}
	}

	m_stScopeStack.front().addSymbol(symbol);
}


T_Symbol getSymbol(string name)
{
//if the element doesnt exist, returns a symbol with __Type_INVALID type
	for (list<SymbolTable>::iterator it_st=m_stScopeStack.begin(); it_st!=m_stScopeStack.end(); ++it_st)
	{
		SymbolTable& currentTable = *it_st;
		if (currentTable.lstSymbols.size() > 0) {
			for (list<T_Symbol>::iterator it=currentTable.lstSymbols.begin(); it!=currentTable.lstSymbols.end(); ++it)
			{
				T_Symbol curr = *it;
				if(name.compare(curr.name) == 0)
				{
					return curr;
				}
			}
			
		}
	}


	T_Symbol symbol;
	symbol.type=__Type_INVALID;
	symbol.name = "__bad__";
	symbol.Type_ARRAY_SIZE=-1;	
	return symbol;
}


void checkByteSize(int value, string valueInStringForm)
{
	if(value>255) 
	{
		errorByteTooLarge(yylineno,valueInStringForm); 
		exit(0);
	}

}


int main()
{	TYPES_TO_STRING.push_back("INT");
	TYPES_TO_STRING.push_back("BYTE");
	TYPES_TO_STRING.push_back("STRING");
	TYPES_TO_STRING.push_back("VOID");
	TYPES_TO_STRING.push_back("BOOL");

	addPrintPrintiDiv0();
	addIndexOutOfRangeFunc();
	yyparse();
	
}

int yyerror(const char * message)
{
	errorSyn(yylineno);
	///maybe pop stack here
	exit(0);
}



/*ou teach me how to resurrect the dead through the force?" asks Vader. Trump smirks, "In time, my apprentice, but first you must learn our most powerful technique - Sub Mode."
Attention: Thank you for coming to Kripp Aryan's show! The greatest show on Earth! Please, those of you in rows 1-8 must be aware you are in the "Salt Down Zone". If you do not want to be sprayed with salt, please see attendant. We have complimentary ponchos. Enjoy the show!.
Dear Twitch Chat users. Do u think its funny to copy pasta everything you see? Copy that, pasta that. Where i grew up copy pasta was taken seriously, and when i come here my mind explodes. Please, respect copy pasta. For me, it's about religion.
hi every1 im new!!!!!!! *holds up spork* my name is katy but u can call me t3h PeNgU1N oF d00m!!!!!!!! lol...as u can see im very random!!!! thats why i came here, 2 meet random ppl like me ^_^... im 13 years old (im mature 4 my age tho!!) i like 2 watch  invader zim w/ my girlfreind(im bi if u dont like it deal w/it) its our favorite tv show!!! bcuz its SOOOO random!!!! shes random 2 of course but i want 2 meet more random ppl =) like they say the more the merrier!!!! lol...neways i hope 2 make alot of freinds here so give me lots of commentses!!!!
As Michael "imaqtpie" Santana sat shivering on the cold pavement, Lisha, who happened to be passing by, decided to share a loaf of bread with him. He wanted to share her kindness, and so he decided to feed in every game henceforth.
Hello Reynad, Fedora the Explorer here, moderator of /r/hearthstone. I am here to tell you that reddit is now your enemy because you missed legal.
I sexually identify as a single, Pringle, ready to mingle. Ever since I was a potato I dreamed of being thin sliced, covered in disgusting oil then heated in a medium oven until reaching climax at the micro second of golden-browness. People bully me, and say things like "what the fuck, you aren't a Pringle", but I know deep down they are just jealous of my inner beauty.
this message can only be posted 10 more times or else serious consequences will commence
 NEVER LUCKY 
Hey Kripp, Asian Dude from Heartharena here. We've noticed you've been away from our website for a long time. Is it the Classic Aggro? We've adjusted our tier list to your more Classic Greed style. Please come back. Best regards, Classic Asian Dude from Heartharena
I sexually identify as an FIM-92 Stinger anti-aircraft missile. My sole erotic fantasy is to explode inside an attack helicopter with such force that their physical vessel is utterly consumed by the intensity of my fiery passion.
I was offered sex today, with a 21 year old girl. In exchange for that, I was supposed to advertise some kind of e-betting website to my friends. Of course I declined because I am a person of high moral standards with a strong willpower. Just as strong as Ebettle, the best betting website on the internet. Now available for children.
I bet all you beta f*gs don't wear antlers either. Science has shown that the male deers with the largest antlers attract the most females, so obviously the exact same principle works for human females. When I walk into the club reeking of sweat with six foot antlers strapped to my head, I get the attention of every female in the room. Pretty much ever man too, that's how powerful the effect is.
Guys stop posting  face. Not many know, but that  guy actually died while streaming Resident Evil. People just assumed that was sleeping, but he died of dehydration. Please respect the dead and stop posting this morbid image 
I hate when people quote songs in their spam... it reminds me of Somebody I Used to Know
I sexually identify as an Ironbeak Owl. Ever since I was a boy I dreamed of being misplayed during tournaments and silencing the incorrect cards. People say to me that a person being an owl is ridiculous and I'm fucking retarded but I don't care, I'm beautiful. I'm having a genetic engineer put ironbeak owl DNA into my body, equipping me with feathers, beaks, and the power to silence others. From now on I want you guys to call me "Owlsen" and respect my right to silence from above and silence needlessly. If you can't accept me you're an owlphobe and need to check your animal privilege. Thank you for understanding.
Kripp you should make a feminist deck with double equality and faceless manipulator (because all are equal), double stonetusk boar (because all men are swines) and a lot of beast synergy (because all men are animals). Thanks Kripp
Hey Imaqtpie! I'm gonna be doing some volunteering next week at a Food Bank and was wondering if you could play a fatty Yasuo game to teach me the Tips n Tricks to feeding! Thanks in advance and God bless
Hello this is the Twitch Chat Examination Team here with anther experiment. We are testing how quickly a message typed into chat is copied and pasted by the mindless hordes. Please, if you're reading this, spread awareness for our cause.
Hey Kripp! So here I was enjoying my favorite food (pizza) and watching your stream having a good time when it started to taste extra salty. It turns out you were being super salty and now have ruined my pizza. Are you going to pay for another pizza or will I have to call the cops? This is serious.
You think this takes concentration?  Try healing in World of Warcrafhow MagicAmy concealed her identity), Sap (like all of us were), or Vanish (like what MagicAmy is about to do)?
Well respected redditor with 197 IQ here chiming in. Seeing as how you've got a number of viewers would it be too hard to maybe mention reddit.com? It's a place to discuss the latest in dank memes, atheism, my little pony and the friend zone.
qt how do i get out of elo hell ive been bronze 5 for 3 years now i main janna adc and i build 5 spirit visages but i keep dying to the golems even when i use smite i know i deserve challenjour so pls help me out senpai masteronii
"Riot games made 5 Dominable League of Legends players who strove to be the best, Imaqtpie, Faker, EU Sucks, and 3 others" - Imaqtpie....
Doublelift best ADC NA? Doublelift's not even the best ADC on CLG
Missed lethal does not exist. It is all a well planned and but the other can be 'a spare i guess'.
Eminem is great but I listen to 3Pac, M&Ms, 3 Chainz, Big Wayne, Small Sean, 60 Cent, Snoop Catt, Mr. Dre, Ice Cubed, Old Jeezy, Jay-Y, Soulja Girl, Jizz Khalifa, Anna Kendrick Lamar, Hard-E, Andre 2999, Big B, Weak Mill, Semi-Automatic Kelly, Adult Cudi, Wu-Tang Tag Team, KRS-Two, and Kanye East instead.
Hello Children, this is Sandown's mother, I am here to politely ask you all to stop making fun of my son. He has always had social problems and it really hurts his feelings when you guys make fun of him. I'm sure you will all be reasonable about this.
Honestly, that's what Icall a cool story bro. Such a riveting tale, I honestly copy andpasted itto word, saved on my hard drive, backed it up on a jump drive, drove to the bank, put the jump drive in the safe deposit box, and will leave it there until my kids turn about 12 (when they can actually state their age, and ask what it is I'm showing them), when I will pick it up, put it in an old USB drive reader and relay this cool story to them and tell them, "kids, this is what a cool story should look and sound like...not like the stories your generation tells
Hey Kripp, Im excited to think of what the next hoodie color will be.  This ones been going strong 20 days in a row now.  Maybe we'll go back to the blue one or even the other light grey one that was worn for 30+ days.  It's like a game now.
Hello twitch admins. I am here to report a streamer named "TSM_Kripp". She is currently violating the new twitch rules, and is constantly moaning suggestively in her stream. I am trying to watch her game but she just keeps yelling "TOPDICK" or "INSANE" after she gets rekt. Please take action against her as soon as you can. Thank you.
I am a degree 6 Zoosexual, sexually and emotionally attracted to Tyrannosaurs and nothing else. Women don't even do it for me. I am cursed to live my life in the misery that my most powerful emotional fantasies will never be even close to coming true. Life is like hell to me. I will never know true love.
It was a hot and sultry night at the c9 gaming house. everyone was in bed except for meteos and sneaky. "we can't keep doing this, baby" says sneaky. "put that mouth to use, you dirty tramp" replies meteos. "LCS starts tmrw, and if you expect me to carry you again, i need to you to suck me to completion." sneaky grins sl*ttily, and goes to town
All this salt has formed into the giant salt monster known as Kripp.  For all the salt of the ocean can not keep him at bay.  Blame RNG and lose!  Then go to cast another player cause you can't play.  The salt is real, the salt is kripp, and thats why he losses.
The Dead Sea is a salt lake bordering Jordan to the east, and Israell the furniture is gone, my bank accounts are empty and I found out you moved to Europe. What in the heck is going on???
Look guys the rules are pretty simple. You are allowed to copypasta and participate in it, but if you are the only one copy pasting it over and over it is time to stop and think about your life and come up with something better to do
The Ghost of Gaming Future shows Kripp a nice house in the Toronto suburbs. Inside, Kripp, Rania and their sons are happily gaming as a family. "This isn't so bad," says Kripp. "Look closer," speaks the Ghost. Kripp looks in horror to see his sons are using tablets and playing browser cash-shop games. "This is your future Casualarrian."
"PARFAIT!", says the Chief of the French Police. "We now have ze best one! Come my friend, together we can stop ze terrorists! Welcome to our ZNIPER TEAM!!". A smile appears on HufferNudes face. "Let's snipe".
Hello. I am a 15 year old Rhinoceros. The only problem is that my horn on my head is soft and limp. As you may know this is very devastating to a rhino like myself. If there are any rhinos out there that can help me with my problem it would be appreciated. Please dont copy paste this. This is my story.
Dear Kripp, it has come to my attention that one of your mods "Leifman" has been abusing his authority as mod and banning people for no good reason. I would appreciate if you took some time out of your schedule to take action and remove his mod status. Thank you!
Studies show that ingesting too much salt can kill healthy bacteria ie. Is that a NON GOLDEN CHILLWIND YETI FOR CRYING OUT LOUD? God save your barbarian soul, you filthy peasant... I was raised in an age where CLASS was valued. Im going to kaceytrons stream where i know ill find real quality
WE ARE KAPPA , KAPPA LIVES IN OUR SOUL AND WE WILL PRAY HIM DAY AND NIGHT FOR THE DONGERINOS HEARTHSTONERINOS FROM DUMBLANDIA THANKS FOR HEARD AND SORRY FOR BAD ENGLAND KAPPA
fuckin reymad m8, why do you look like you're 15 years old? You even old enough to drive there m8? I used to remember back in the old day your dad would yell at you on stream. I miss those days. Somebody needs to smash your face m8 all you do is play hearthstone all day. You obviously don't lift with those leper gnome guns you got there.
If Reynad was a Hearthstone card he'd be a Giant Douche
anyone else fap to reynad?
Reynad is like a pigeon. Pigeons are too self-absorbed to care about anyone else. They poo on people they don't like; they poo on people they don't even know. The only real difference between reynad and a pigeon is that reynad intends to rob us of our lives, our health, our honor, and our belongings.
Hello fair maiden Reynad, this is the valiant knight Sir Coppus Pastaronus. I have come to rescue you from the mystical Tower of Salt, where the cruel innkeeper RNGesus has pounded your sweet, supple orifice relentlessly to the beat of Lord  Please no paste.
Dear Reynad, I am a representative of Twitch tv. I am sad to inform you that due to the random aspects of the RNG associated with soulfire's discard process this can be considered illegal gambling and you are going to be forced to stop these games immediately. Much love, Twitch tv admins. please no copypasterino al pacino greasy guido
Reynad, you have inspired me so much. Without you I would never have been able to come to terms with my genital warts and how they are natural. I am no longer ashamed of them and would like you to someday see them! Thank you.
Hello, my name is Ho Lee Fuk and i are fromm Chinaland Father say i need become doctor and make her proud but i chose become HS player like Reckful. Father not happy with choice and told commit sudoku but i know i make right choice. Sorry i no speak propeller engrish and pls no coppy pasterino dongerino frappucino cappucino al pacino
That's it, I'm done. *** this chat. It's devolved into a mass of retarded copy pastes and face spam. The quality of twitch chat has been declining for a while, but this is the last straw. That's it. I'm done. I'm uninstalling the internet, chopping off my dick and moving to *** Antarctica, at least the bacteria there will be *** smarter discourse.
ELEPHANTS GUIDE ME
69? 
Hey reynad, ever since I listened to your tips my hair has never been better! But now I need pube-styling tips. Do you trim or straighten it? I was thinking an Abe Lincoln look. what do you think?
This is an automated message from Twitch TV. We have been experiencing technical difficulties related to the  face. Please confirm that your  face is working properly.
 DUDUDUDUDUDUU 
Hello Reynad my name is Dennis, and I am 12. I drink 3 beers per day because of your stream. Mom said I am going to leave outside like a dog because drunk children live outside. I am sad. please help me.
Kripp we are all very disappointed in you. Playing games because Blizzard will pay you? What are you? A shill now? Remember when you played hardcore games like Hearthstone, Minesweeper, or Diablo 3? Everything changed when you got a girlfriend. I'm starting to wonder if you even drink OJ anymore.
hello, il mio nome is GIROLAMO SAVORANOLA I my italiano. I want be profesionali playeretti of Defenders of the Agnolotti. the I sold all my spaghetti so i can bought a branderini new coputterini and farma all gaems. Per favore no coperinato pasterinato caramel macchiato
DotA, LoL, HoN and HoTS are just a copy of Pong, and Pong is a copy of tennis
Wtf are you doing, just hunter's mark face and kill him?! 
guys could you please be a little serious and stop the spamming? people are trying to enjoy the stream here, its hard to find a place where im accepted for who i am and when i see you all spam kripps chat it makes me feel rly bad because i know that he wants you to learn instead of joke around as well
YOU SHOULD OF LEROYED OH GOD I'M SO FUCKING STUPID I'M GONNA SHIT
   
Europe was founded in 1848 by Walker Texas Ranger when he rode a horse across the Atlantic, he called it "Eastern USA" which was eventually abbreviated as just "EU"
Hi my name ist Sergei. Sorry for bad england. I started bronzer II but from watch trick2g sterm everyday i climb to PLat 8. Everyday i walk 20 miles frozen tundra to stream leagu of legion on 1980 Dell computer processor. I left my wife and the vodka make me become alcoholic and i need stream supporter for helps. Please no copy pastaerino dongerino cappucino reno nevadarino bongerino plz.
Hi Kripparrian. For 2 weeks I was stuck in Hearthstone. I nearly gave up on it, however, after watching your stream and learning so much, I decided to buy 40 packs and make a new deck. Lo and behold after my 7th game I finally defeated the first boss Honker. Thank you Kripparrian.
Hello kripp, I am psychic peter pasterino who can predict the futurino. I have mind visioned that in 5 years you will walk down the isle to Space Jam and topkiss your bride, Hafu. There were many Well Mets and toasts with OJ. If you wish for this to come true, though, you must proclaim your true love for her soon before it is too laterino.
Dearest Kripparian, Jarnitro here. I am so confudido about how i lost that game. Please use your masterino of top deckarino to teach me how to win this game. I will be your fettucinni pepperoni boy forever.
Silence the silenced watcher to counter the silence
 NaCl 
 = Reynad Tears (no space)
 = Dog Face (no space)
hello kripp, I am from the future. I am best friends with your son, Dennis Morosan. Your wife, Hafu, sent me to tell you Well Met and to message her how much you value penguins and OJ
Kripp this is Dr. Zeus Stromboloupolous. We need you to immediately star drinking MILK and EAT chicken at least once every week. Otherwise RIP is veganiro pepperoni
Kripp pls make up with papa so u can go to the doctors, you cannot get help in a 3rd world country AKA the EU pls come back to NA where we have doctors
Krippler's aim is to establish a New Order of absolute Nazi German hegemony in the Twitch Metaverse. To this end, his foreign and domestic policies had the aim of seizing Lebensraum ("living space") for the Donger people. Under Krippler's rule, in 1941 German forces and their European allies occupied most of Europe and North Africa.
so i was walking down the road today and 2 black hoodlums approached me. They asked "dawg u a crip or a blood fool". Startled, i muttered "I'm a kripp". The power of morosan rushed through my body, i raised my donger and blew both of the hoodlums away with 100% pure orange juice from concentrate. Value.
I can no longer resist the pizza. I open the box and unzip my pants with my other hand. As I penetrate the gooey cheese, I moan in ecstacy. The mushrooms and Italian sausage are rough, but the sauce is deliciously soothing. I blow my load in seconds. As you leave the bathroom, I exit through the front door....
hi kripp i em olombo bongo frm Somalia. erryday i watch u strem u are favourit stremmer i sell kidney for a laptop 2 i can watch u strem. i work in bannana facotry an 1 day i cum to america LAND OF FREEDDOM so i be lyke u and strem 4 monies insted of pick banana, WOO USAsss al pacino, malcolm in middle, stevo-o, mike 'the situation' sorrentino.
When I fart Kripp feel the fart. He hard press A and D and try to avoid the fart. But Kripp smell the fart. My viscosity meter is always highest when Kripp in the room. We sneakily squeak until light of dawn. All becoming well met.
Hello Kripp, I am famous child soldier militia commander Joseph Kony. I want to help you make your own child soldier militia too so we can fight the white man as one. I hope you make the right decision and remember, dongerino dongerino please no copi pasterino banerino Al Pacino cappuccino orange moccha frappuccino steal your kiderino.
Toronto authorities reported that Octavian "kripp" Morosan passed away last night in the Toronto east general Hospital after a bike accident near his home
Dear nazi mods. you may have permabanned my other account, but shitposting will always find a way. I will lie about how to make faces. I will accuse teams of 322. I will raise my dongers. So don't even waste your time banning me, because I am like a boomerang. I will always return. Pls no copy pasterino dongerino cappucino.
Well I regret to inform you Kripp that your choice to return to Path of Poe has confirmed my suicide tonight. It had been a fun ride, but I simply cannot afford to live any longer. Please bless me that I may rip in paparolies, as this will be my fifth suicide this week.
Kripp if you're here right now reading this I want you to know I dream of you. Sometimes I sit alone in my bathroom with the light off and pretend to be you. I'll say things like "hey guys how's it goin' Kripparrian here", and for a brief moment I feel you inside me...
when is google gonna buy ad space on reynads forehead??
Please for the love of god Kripp just lick your goddam knee. I've been sitting here for 10 hours straight watching that boney *** knee of yours by your big lushous mouth. Please just fulfill this one wish I have and lick that sexy *** knee of yours so I can blow my creamy load all over myself and slowly fall into a deep sleep.
You have to concede... He has a wisp
gullin15 is the best streamer
Well Met Kripp. This is Hitler from 1940. I came here to recruit your mods to be officers in my third reich army. please no copy seig heil pasterino .
This is a message from the 4/20 blazeit foundation. If you would like to donate to the DESTROY THE NAZI MODS cause, please type into the chat, thank you, and remember to raise your donger
Dearest Kripparian, this is the Donger Police. We have inside information that states your chat has not been raising a sufficient amount of dongers. We are going to have to shut down your stream if you don't ask your chat to raise their dongers.
*/