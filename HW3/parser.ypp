
%{
	#include <iostream>
	#include "definitions.h"
	#include "output.hpp"
	#include <stdio.h>
	using namespace output;

	
	extern int yylineno;
	extern int yylex();
	int yyerror(const char *);

	///////// OUR GLOBAL VARS DEFINITIONS//////////
	int m_iWhileCounter = 0;
	ScopeStack m_stScopeStack;
	int m_iCurrentOffset = 0;
	int m_iCurrentFuncOffset=-1;

	std::vector<std::string>  TYPES_TO_STRING;
	
	  
	
	
	///////// OUR FUNCTIONS DEFINITIONS//////////
	void validateNotAlreadyDefined(std::string name);
	void validateDefined(std::string name, bool isVariable);
	void validateAssignment(Type lhs, Type rhs);
	void validateAssignmentArray(std::string arrName, int index, Type rhsType, int num_value);
	Type validateAndGetTypeByName(std::string name);

	void createAndPushSymbol(std::string name, Type type, int size);
	
	void start_Scope();
	void end_Scope();

	void isBoolean(Type t);
	void isIntOrByte(Type t);
	void validateArraySize(int numValue, std::string name);
	
	
	Type getTypeBinop(Type t1, Type t2);
	T_Symbol getSymbol(std::string name);
%}

%token VOID INT BYTE RETURN B SC COMMA ID STRING TRUE FALSE

%nonassoc RPAREN LBRACE RBRACE LBRACK RBRACK LPAREN

%nonassoc IF
%nonassoc ELSE
 
%token WHILE
%token BREAK
%token NUM
%token BOOL

%right ASSIGN

%left OR    
%left AND    

%left 	RELOP_2
%nonassoc RELOP_1

%left BINOP_2
%left BINOP_1

%right NOT




%%

Program		:	Funcs;
Funcs		:	FuncDecl	Funcs
			|	;

FuncDecl	:	RetType	ID	LPAREN	Formals RPAREN	LBRACE ScopeStart Statements ScopeEnd	RBRACE ; 

RetType		:	Type {$$.type=$1.type;}
			| 	VOID {$$.type=Type_VOID;}
			;

Formals		:	FormalsList
			|	;

FormalsList	:	FormalDecl
			|	FormalDecl	COMMA	FormalsList;
				
FormalDecl	:	Type	ID 
			|	Type	ID	LBRACK	NUM	RBRACK 
			|	Type	ID	LBRACK	NUM		B	RBRACK;
				
Statements	:	Statement
			|	Statements	Statement

Statement	:	LBRACE	ScopeStart	Statements ScopeEnd	RBRACE
			|	Type	ID	SC 	{ validateNotAlreadyDefined($2.name); createAndPushSymbol($2.name, $1.type,-1);}
			|	Type	ID	ASSIGN	Exp	SC	{ validateNotAlreadyDefined($2.name); validateAssignment($1.type, $4.type); createAndPushSymbol($2.name, $1.type,-1);}
			|	Type	ID	LBRACK	NUM	RBRACK	SC { validateNotAlreadyDefined($2.name); isIntOrByte($4.type); validateArraySize($4.num_value, $2.name); createAndPushSymbol($2.name, $1.type,$4.num_value); }
			|	Type	ID	LBRACK	NUM	B 	RBRACK SC {	validateNotAlreadyDefined($2.name); isIntOrByte($4.type); validateArraySize($4.num_value, $2.name); createAndPushSymbol($2.name,Type_BYTE,$4.num_value); }
			|	ID	ASSIGN	Exp	SC { validateDefined($1.name,true);  validateAssignment(validateAndGetTypeByName($1.name),$3.type);}
			|	ID	LBRACK  Exp RBRACK ASSIGN Exp SC  { validateDefined($1.name,true);  isIntOrByte($3.type);  validateAssignmentArray($1.name,  $3.num_value, $6.type, $6.num_value);}
			|	Call SC
			|	RETURN  SC
			|	RETURN  Exp SC
			| 	IF LPAREN Exp_boolean RPAREN Statement
			|   IF LPAREN Exp_boolean RPAREN Statement ELSE Statement
			|	WHILE startWhile LPAREN Exp_boolean RPAREN Statement endWhile
			|	BREAK SC {if ((m_iWhileCounter) <= 0) {errorUnexpectedBreak(yylineno); exit(0);}}
			;
			


startWhile	: {m_iWhileCounter++;};
endWhile	: {m_iWhileCounter--;};



				
Call 		:	ID LPAREN ExpList RPAREN
			|  ID LPAREN RPAREN;
				
ExpList 	:	Exp
			|	Exp COMMA ExpList;
			
Type		:	INT		{ $$.type = Type_INT;}
			|	BYTE	{ $$.type = Type_BYTE;}
			|	BOOL	{ $$.type = Type_BOOL;};
			
Exp 		:	LPAREN Exp RPAREN {$$.type=$2.type;}
			|	ID LBRACK Exp RBRACK {$$.type=validateAndGetTypeByName($1.name); isIntOrByte($3.type); /*TODO make exp type array*/}
			|	ID				{$$.type = validateAndGetTypeByName($1.name);}
			|	Call
			|	NUM				{ $$.type = Type_INT; $$.num_value = $1.num_value;}
			| 	NUM B			{ $$.type = Type_BYTE; $$.num_value = $1.num_value;}
			| 	STRING			{ $$.type = Type_BOOL;}
			|	TRUE			{ $$.type = Type_BOOL;}
			|	FALSE			{ $$.type = Type_BOOL;}
			|	Exp BINOP_1 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = getTypeBinop($1.type, $3.type);}
			|	Exp BINOP_2 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = getTypeBinop($1.type, $3.type);}
			|	Exp AND Exp		{ isBoolean($1.type); isBoolean($3.type); $$.type = Type_BOOL;}
			|	Exp OR Exp		{ isBoolean($1.type); isBoolean($3.type); $$.type = Type_BOOL;}
			| 	Exp RELOP_1 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = Type_BOOL;}
			| 	Exp RELOP_2 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = Type_BOOL;}
			|	NOT Exp			{ isBoolean($2.type);  $$.type = Type_BOOL;}
			;

Exp_boolean	:   Exp {isBoolean($1.type);}
			;

ScopeStart	:	{start_Scope();}
			;
		
ScopeEnd	:	{end_Scope();}
			;

%%

void validateArraySize(int numValue, std::string name)
{
	if (numValue <= 0 || numValue >= 256)
	{
		errorInvalidArraySize(yylineno, name);
	}
}

void validateAssignmentArray(std::string arrName, int index, Type rhsType, int num_value)
{
	if (num_value == -1) // cannot be -1
	{
		errorMismatch(yylineno);
	}
	T_Symbol result=getSymbol(arrName);
	if(result.type ==__Type_INVALID)
	{
		errorDef(yylineno, arrName);	
		exit(0);
	}
	validateAssignment(result.type, rhsType);
	if (result.Type_ARRAY_SIZE <= index || index < 0)
	{
		/// do something?
	}
	
}

Type validateAndGetTypeByName(std::string name)
{
	for (std::list<SymbolTable>::iterator it_st=m_stScopeStack.begin(); it_st!=m_stScopeStack.end(); ++it_st)
	{
		SymbolTable& currentTable = *it_st;
		if (currentTable.lstSymbols.size() > 0) {
			for (std::list<T_Symbol>::iterator it=currentTable.lstSymbols.begin(); it!=currentTable.lstSymbols.end(); ++it)
			{
				T_Symbol curr = *it;
				if(name == curr.name)
				{
					return curr.type;
				}
			}
			
		}
	}
	
	errorUndef(yylineno, name);
	exit(0);
	return (Type) -1;
}

Type getTypeBinop(Type t1, Type t2)
{
	if (t1 == t2)
	{
		//cout << "binop type is: " << t1 << endl;
		return t1;
	}
	//cout << "binop type is: " << Type_INT << endl;
	return Type_INT;
}

void isBoolean(Type t)
{
	
	if (t != Type_BOOL)
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

void isIntOrByte(Type t)
{
	//cout << "t type: " << t << endl;
	if (t != Type_INT && t != Type_BYTE)
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

void validateAssignment(Type lhs, Type rhs)
{
	//TODO- if its an array, do we need to check that the assignment is done to a valid position? a[5] not overflowing)
	//cout << "lhs type: " << lhs << "rhs type: " << rhs << endl;
	if (lhs != rhs)
	{
		if (lhs == Type_INT && rhs == Type_BYTE)
		{
			return;
		}
		errorMismatch(yylineno);
		exit(0);
	}
}

void start_Scope()
{
	SymbolTable newTable;
	m_stScopeStack.push_front(newTable);
}

void end_Scope()
{
	SymbolTable& top = m_stScopeStack.front();
	if (top.lstSymbols.size() > 0) {

		endScope();
		for (std::list<T_Symbol>::iterator it=top.lstSymbols.begin(); it!=top.lstSymbols.end(); ++it) {
			T_Symbol curr = *it;
			printID(curr.name, curr.offset, TYPES_TO_STRING[curr.type]);
			m_iCurrentOffset--;
		}
	}
	m_stScopeStack.pop_front();
}



void validateNotAlreadyDefined(std::string name)
{
	
	T_Symbol result=getSymbol(name);
	if(result.type!=__Type_INVALID)
	{
		//if type is not invalid, symbol exists
		//, bad.
		errorDef(yylineno, name);	
		exit(0);
	}	
	
}


//will return error if its not defined. 
void validateDefined(std::string name, bool isVariable) 
{
	T_Symbol result=getSymbol(name);
	if(result.type==__Type_INVALID)
	{
		//doesnt exist, return error
		if(isVariable==true)
		{
			errorUndef(yylineno, name);	
		}
		else
		{
			errorUndefFunc(yylineno, name);
		}		
		exit(0);
	}

}

void createAndPushSymbol(std::string name, Type type, int size)
{
	T_Symbol symbol;
	symbol.name = name;
	symbol.type = type;
	symbol.offset = m_iCurrentOffset++;
	symbol.Type_ARRAY_SIZE=-1;//redundant, taken care of in constructor


	if(size>-1)//its an array!
	{
		symbol.Type_ARRAY_SIZE=size;		
		m_iCurrentOffset+=size-1;
	}

	m_stScopeStack.front().addSymbol(symbol);
}


//if the element doesnt exist, returns a symbol with __Type_INVALID type
T_Symbol getSymbol(std::string name)
{
	for (std::list<SymbolTable>::iterator it_st=m_stScopeStack.begin(); it_st!=m_stScopeStack.end(); ++it_st)
	{
		SymbolTable& currentTable = *it_st;
		if (currentTable.lstSymbols.size() > 0) {
			for (std::list<T_Symbol>::iterator it=currentTable.lstSymbols.begin(); it!=currentTable.lstSymbols.end(); ++it)
			{
				T_Symbol curr = *it;
				if(name == curr.name)
				{
					return curr;
				}
			}
			
		}
	}


	T_Symbol symbol;
	symbol.type=__Type_INVALID;
	symbol.name = "__bad__";	
	return symbol;
}

int main()
{	TYPES_TO_STRING.push_back("INT");
	TYPES_TO_STRING.push_back("BYTE");
	TYPES_TO_STRING.push_back("STRING");
	TYPES_TO_STRING.push_back("VOID");
	TYPES_TO_STRING.push_back("BOOL");
	yyparse();
}

int yyerror(const char * message)
{
	errorLex(yylineno);
	///maybe pop stack here
	exit(0);
}