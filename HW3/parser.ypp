%{
	#include <iostream>
	#include "definitions.h"
	#include "output.hpp"
	#include <stdio.h>
	using namespace output;
	 
	extern int yylineno;
	extern int yylex();
	int yyerror(const char *);

	///////// OUR GLOBAL VARS DEFINITIONS//////////
	int m_iWhileCounter = 0;
	ScopeStack m_stScopeStack;
	int m_iCurrentOffset = 0;
	int m_iCurrentFuncOffset=-1;

	std::vector<std::string>  TYPES_TO_STRING;
	
	  
	
	
	///////// OUR FUNCTIONS DEFINITIONS//////////
	void validateNotAlreadyDefined(std::string name);
	void createAndPushSymbol(std::string name, Type type);
	void validateAssignment(Type lhs, Type rhs);
	void start_Scope();
	void end_Scope();
%}

%token VOID INT BYTE RETURN B SC COMMA ID STRING TRUE FALSE

%nonassoc RPAREN LBRACE RBRACE LBRACK RBRACK LPAREN

%nonassoc IF
%nonassoc ELSE
 
%token WHILE
%token BREAK
%token NUM
%token BOOL

%right ASSIGN

%left OR    
%left AND    

%left 	RELOP_2
%nonassoc RELOP_1

%left BINOP_2
%left BINOP_1

%right NOT




%%

Program		:	Funcs;
Funcs		:	FuncDecl	Funcs
			|	;

FuncDecl	:	RetType	ID	LPAREN	Formals	RPAREN	LBRACE ScopeStart Statements ScopeEnd	RBRACE;
RetType		:	Type
			| 	VOID;

Formals		:	FormalsList
			|	;

FormalsList	:	FormalDecl
			|	FormalDecl	COMMA	FormalsList;
				
FormalDecl	:	Type	ID
			|	Type	ID	LBRACK	NUM	RBRACK 
			|	Type	ID	LBRACK	NUM		B	RBRACK;
				
Statements	:	Statement
			|	Statements	Statement

Statement	:	LBRACE	ScopeStart	Statements ScopeEnd	RBRACE
			|	Type	ID	SC 	{validateNotAlreadyDefined($2.name); createAndPushSymbol($2.name, $1.type);}
			|	Type	ID	ASSIGN	Exp	SC	{validateNotAlreadyDefined($2.name); validateAssignment($1.type, $4.type); createAndPushSymbol($2.name, $1.type);}
			|	Type	ID	LBRACK	NUM	RBRACK	SC
			|	Type	ID	LBRACK	NUM	B 	RBRACK SC 
			|	ID	ASSIGN	Exp	SC
			|	ID	LBRACK  Exp RBRACK ASSIGN Exp SC
			|	Call SC
			|	RETURN  SC
			|	RETURN  Exp SC
			| 	IF LPAREN Exp RPAREN Statement
			|   IF LPAREN Exp RPAREN Statement ELSE Statement
			|	WHILE startWhile LPAREN Exp RPAREN Statement endWhile
			|	BREAK SC {if ((m_iWhileCounter) <= 0) {errorUnexpectedBreak(yylineno); exit(1);}}
			;
			


startWhile	: {m_iWhileCounter++;};
endWhile	: {m_iWhileCounter--;};



				
Call 		:	ID LPAREN ExpList RPAREN
			|  ID LPAREN RPAREN;
				
ExpList 	:	Exp
			|	Exp COMMA ExpList;
			
Type		:	INT
			|	BYTE
			|	BOOL;
			
Exp 		:	LPAREN Exp RPAREN
			|	ID LBRACK Exp RBRACK
			|	ID
			|	Call
			|	NUM			
			| 	NUM B			{ $$.type = Type_BYTE;}
			| 	STRING
			|	TRUE
			|	FALSE
			|	Exp BINOP_1 Exp
			|	Exp BINOP_2 Exp
			|	Exp AND Exp
			|	Exp OR Exp
			| 	Exp RELOP_1 Exp
			| 	Exp RELOP_2 Exp
			|	NOT Exp;

ScopeStart	:	{start_Scope();}
			;
		
ScopeEnd	:	{end_Scope();}
			;

%%

void validateAssignment(Type lhs, Type rhs)
{
	cout << "lhs type: " << lhs << "rhs type: " << rhs << endl;
	if (lhs != rhs)
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

void start_Scope()
{
	SymbolTable newTable;
	m_stScopeStack.push_front(newTable);
}

void end_Scope()
{
	SymbolTable& top = m_stScopeStack.front();
	if (top.lstSymbolTable.size() > 0) {

		endScope();
		for (std::list<T_Symbol>::iterator it=top.lstSymbolTable.begin(); it!=top.lstSymbolTable.end(); ++it) {
			T_Symbol curr = *it;
			printID(curr.name, curr.offset, TYPES_TO_STRING[curr.type]);
			m_iCurrentOffset--;
		}
	}
	m_stScopeStack.pop_front();
}

void validateNotAlreadyDefined(std::string name)
{

}

void createAndPushSymbol(std::string name, Type type)
{
	T_Symbol symbol;
	symbol.name = name;
	symbol.type = type;
	symbol.offset = m_iCurrentOffset++;

	//TODO: if its an array, offset should be +=arraysize

	m_stScopeStack.front().addSymbol(symbol);
}

int main()
{	TYPES_TO_STRING.push_back("INT");
	TYPES_TO_STRING.push_back("BYTE");
	TYPES_TO_STRING.push_back("STRING");
	TYPES_TO_STRING.push_back("VOID");
	TYPES_TO_STRING.push_back("B");
	TYPES_TO_STRING.push_back("BOOL");
	yyparse();
}

int yyerror(const char * message)
{
	cout<<"Parse error: "<<message<<endl;
	///maybe pop stack here
	exit(0);
}