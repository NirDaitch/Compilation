%{
	#include <iostream>
	#include "definitions.h"
	#include "output.hpp"
	#include <stdio.h>
	using namespace output;

	
	extern int yylineno;
	extern int yylex();
	int yyerror(const char *);

	///////// OUR GLOBAL VARS DEFINITIONS//////////
	int m_iWhileCounter = 0;
	ScopeStack m_stScopeStack;
	int m_iCurrentOffset = 0;
	int m_iCurrentFuncOffset=-1;

	std::vector<std::string>  TYPES_TO_STRING;
	
	  
	
	
	///////// OUR FUNCTIONS DEFINITIONS//////////
	void validateNotAlreadyDefined(std::string name);
	void createAndPushSymbol(std::string name, Type type);
	void validateAssignment(Type lhs, Type rhs);
	void start_Scope();
	void end_Scope();
	void isBoolean(Type t);
	void isIntOrByte(Type t);
	Type getTypeBinop(Type t1, Type t2);
	Type validateAndGetTypeByName(std::string name);
	
	T_Symbol getSymbol(std::string name);
%}

%token VOID INT BYTE RETURN B SC COMMA ID STRING TRUE FALSE

%nonassoc RPAREN LBRACE RBRACE LBRACK RBRACK LPAREN

%nonassoc IF
%nonassoc ELSE
 
%token WHILE
%token BREAK
%token NUM
%token BOOL

%right ASSIGN

%left OR    
%left AND    

%left 	RELOP_2
%nonassoc RELOP_1

%left BINOP_2
%left BINOP_1

%right NOT




%%

Program		:	Funcs;
Funcs		:	FuncDecl	Funcs
			|	;

FuncDecl	:	RetType	ID	LPAREN	Formals RPAREN	LBRACE ScopeStart Statements ScopeEnd	RBRACE ; 

RetType		:	Type
			| 	VOID;

Formals		:	FormalsList
			|	;

FormalsList	:	FormalDecl
			|	FormalDecl	COMMA	FormalsList;
				
FormalDecl	:	Type	ID
			|	Type	ID	LBRACK	NUM	RBRACK 
			|	Type	ID	LBRACK	NUM		B	RBRACK;
				
Statements	:	Statement
			|	Statements	Statement

Statement	:	LBRACE	ScopeStart	Statements ScopeEnd	RBRACE
			|	Type	ID	SC 	{validateNotAlreadyDefined($2.name); createAndPushSymbol($2.name, $1.type);}
			|	Type	ID	ASSIGN	Exp	SC	{validateNotAlreadyDefined($2.name); validateAssignment($1.type, $4.type); createAndPushSymbol($2.name, $1.type);}
			|	Type	ID	LBRACK	NUM	RBRACK	SC
			|	Type	ID	LBRACK	NUM	B 	RBRACK SC 
			|	ID	ASSIGN	Exp	SC
			|	ID	LBRACK  Exp RBRACK ASSIGN Exp SC
			|	Call SC
			|	RETURN  SC
			|	RETURN  Exp SC
			| 	IF LPAREN Exp RPAREN Statement
			|   IF LPAREN Exp RPAREN Statement ELSE Statement
			|	WHILE startWhile LPAREN Exp RPAREN Statement endWhile
			|	BREAK SC {if ((m_iWhileCounter) <= 0) {errorUnexpectedBreak(yylineno); exit(1);}}
			;
			


startWhile	: {m_iWhileCounter++;};
endWhile	: {m_iWhileCounter--;};



				
Call 		:	ID LPAREN ExpList RPAREN
			|  ID LPAREN RPAREN;
				
ExpList 	:	Exp
			|	Exp COMMA ExpList;
			
Type		:	INT		{ $$.type = Type_INT;}
			|	BYTE	{ $$.type = Type_BYTE;}
			|	BOOL	{ $$.type = Type_BOOL;};
			
Exp 		:	LPAREN Exp RPAREN
			|	ID LBRACK Exp RBRACK 
			|	ID				{$$.type = validateAndGetTypeByName($1.name);}
			|	Call
			|	NUM				{ $$.type = Type_INT;}
			| 	NUM B			{ $$.type = Type_BYTE;}
			| 	STRING			{ $$.type = Type_BOOL;}
			|	TRUE			{ $$.type = Type_BOOL;}
			|	FALSE			{ $$.type = Type_BOOL;}
			|	Exp BINOP_1 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = getTypeBinop($1.type, $3.type);}
			|	Exp BINOP_2 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = getTypeBinop($1.type, $3.type);}
			|	Exp AND Exp		{ isBoolean($1.type); isBoolean($3.type); $$.type = Type_BOOL;}
			|	Exp OR Exp		{ isBoolean($1.type); isBoolean($3.type); $$.type = Type_BOOL;}
			| 	Exp RELOP_1 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = Type_BOOL;}
			| 	Exp RELOP_2 Exp	{ isIntOrByte($1.type); isIntOrByte($3.type); $$.type = Type_BOOL;}
			|	NOT Exp			{ isBoolean($2.type);  $$.type = Type_BOOL;};

ScopeStart	:	{start_Scope();}
			;
		
ScopeEnd	:	{end_Scope();}
			;

%%

Type validateAndGetTypeByName(std::string name)
{
	for (std::list<SymbolTable>::iterator it_st=m_stScopeStack.begin(); it_st!=m_stScopeStack.end(); ++it_st)
	{
		SymbolTable& currentTable = *it_st;
		if (currentTable.lstSymbols.size() > 0) {
			for (std::list<T_Symbol>::iterator it=currentTable.lstSymbols.begin(); it!=currentTable.lstSymbols.end(); ++it)
			{
				T_Symbol curr = *it;
				if(name == curr.name)
				{
					return curr.type;
				}
			}
			
		}
	}
	
	errorUndef(yylineno, name);
	exit(0);
	return (Type) -1;
}

Type getTypeBinop(Type t1, Type t2)
{
	if (t1 == t2)
	{
		//cout << "binop type is: " << t1 << endl;
		return t1;
	}
	//cout << "binop type is: " << Type_INT << endl;
	return Type_INT;
}

void isBoolean(Type t)
{
	//TODO should we verify types are identical?
	if (t != Type_BOOL)
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

void isIntOrByte(Type t)
{
	//cout << "t type: " << t << endl;
	if (t != Type_INT && t != Type_BYTE)
	{
		errorMismatch(yylineno);
		exit(0);
	}
}

void validateAssignment(Type lhs, Type rhs)
{
	//cout << "lhs type: " << lhs << "rhs type: " << rhs << endl;
	if (lhs != rhs)
	{
		if (lhs == Type_INT && rhs == Type_BYTE)
		{
			return;
		}
		errorMismatch(yylineno);
		exit(0);
	}
}

void start_Scope()
{
	SymbolTable newTable;
	m_stScopeStack.push_front(newTable);
}

void end_Scope()
{
	SymbolTable& top = m_stScopeStack.front();
	if (top.lstSymbols.size() > 0) {

		endScope();
		for (std::list<T_Symbol>::iterator it=top.lstSymbols.begin(); it!=top.lstSymbols.end(); ++it) {
			T_Symbol curr = *it;
			printID(curr.name, curr.offset, TYPES_TO_STRING[curr.type]);
			m_iCurrentOffset--;
		}
	}
	m_stScopeStack.pop_front();
}

void validateNotAlreadyDefined(std::string name)
{
	///TODO: implement
}

void createAndPushSymbol(std::string name, Type type)
{
	T_Symbol symbol;
	symbol.name = name;
	symbol.type = type;
	symbol.offset = m_iCurrentOffset++;

	//TODO: if its an array, offset should be +=arraysize

	m_stScopeStack.front().addSymbol(symbol);
}

int main()
{	TYPES_TO_STRING.push_back("INT");
	TYPES_TO_STRING.push_back("BYTE");
	TYPES_TO_STRING.push_back("STRING");
	TYPES_TO_STRING.push_back("VOID");
	TYPES_TO_STRING.push_back("BOOL");
	yyparse();
}

int yyerror(const char * message)
{
	cout<<"Parse error: "<<message<<endl;
	///maybe pop stack here
	exit(0);
}